<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cartes mémoire physique</title>
    <link rel="preconnect" href="https://cloud.umami.is" crossorigin />
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="a052a820-83ee-48c6-bf8a-9b3c2b3a8fd3"
    ></script>
    <style>
      :root {
        --bg: #f7f7f9;
        --fg: #0f172a;
        --muted: #6b7280;
        --accent: #111827;
        --btn: #111827;
        --btn-fg: #ffffff;
        --radius: clamp(6px, 8%, 52px);
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.12);
        --shadow-active: 0 20px 60px rgba(0, 0, 0, 0.16);
        --skeleton-bg: #e5e7eb;
        --skeleton-shine: #f3f4f6;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
        display: grid;
        min-height: 100dvh;
        grid-template-rows: auto 1fr auto;
      }
      header {
        padding: 22px 20px 10px;
        text-align: center;
      }
      h1 {
        font-size: 22px;
        margin: 0 0 8px;
        letter-spacing: 0.2px;
      }
      .sub {
        color: var(--muted);
        font-size: 14px;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 10px 16px 22px;
        width: 100%;
      }

      /* Stage */
      .stage {
        position: relative;
        margin: 10px auto 18px;
        width: min(92vw, 1000px);
        perspective: 2000px;
        -webkit-perspective: 2000px;
        user-select: none;
        display: block;
      }

      /* Skeleton loader */
      .skeleton-card {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--skeleton-bg);
        overflow: hidden;
        opacity: 0;
        transition: opacity 0.2s ease-out;
      }

      .skeleton-card.visible {
        opacity: 1;
      }

      .skeleton-card::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          var(--skeleton-shine),
          transparent
        );
        animation: shimmer 1.5s infinite;
      }

      @keyframes shimmer {
        to {
          left: 100%;
        }
      }

      /* Shell holds the 3D space */
      .card-shell {
        position: relative;
        width: 100%;
        height: 100%;
        cursor: pointer;
        transition: transform 0.15s ease-out, opacity 0.2s ease-out;
        will-change: transform, opacity;
        contain: paint;
        transform: translateZ(0);
      }

      .card-shell:hover {
        transform: translateY(-2px);
      }

      .card-shell:active {
        transform: translateY(0px) scale(0.98);
      }

      /* Two-phase navigation animations to avoid mid-flight content swap */
      .card-shell.out-left {
        animation: outLeft 140ms ease-out both;
      }
      .card-shell.in-right {
        animation: inRight 180ms ease-out both;
      }
      .card-shell.out-right {
        animation: outRight 140ms ease-out both;
      }
      .card-shell.in-left {
        animation: inLeft 180ms ease-out both;
      }

      @keyframes outLeft {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(-12px);
        }
      }
      @keyframes inRight {
        from {
          opacity: 0;
          transform: translateX(12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      @keyframes outRight {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(12px);
        }
      }
      @keyframes inLeft {
        from {
          opacity: 0;
          transform: translateX(-12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Inner flipper with smooth animation */
      .card3d {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        -webkit-transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
          box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: rotateY(0deg);
        box-shadow: var(--shadow);
        will-change: transform;
      }

      .card3d.no-anim {
        transition: none !important;
      }

      .card3d.flipping {
        box-shadow: var(--shadow-active);
      }

      .card3d.flipped {
        transform: rotateY(180deg);
      }

      .face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        overflow: hidden;
        transition: opacity 0.3s ease-in-out;
      }

      .face.front {
        transform: rotateY(0deg);
      }

      .face.back {
        transform: rotateY(180deg);
      }

      .face img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease-out;
        will-change: opacity;
      }

      .face img.loaded {
        opacity: 1;
      }

      /* Controls with smooth transitions */
      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button,
      .toggle {
        appearance: none;
        border: 0;
        background: var(--btn);
        color: var(--btn-fg);
        padding: 12px 16px;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateY(0);
      }

      button:hover:not(:disabled),
      .toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      button:active:not(:disabled),
      .toggle:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }

      button.secondary {
        background: #e5e7eb;
        color: #111827;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
      }

      .switch {
        width: 42px;
        height: 26px;
        background: #e5e7eb;
        border-radius: 999px;
        position: relative;
        transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .knob {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 999px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      .switch.on {
        background: #e5e7eb;
      }

      .switch.on .knob {
        left: 19px;
      }

      .meta {
        margin-top: 6px;
        text-align: center;
        color: var(--muted);
        font-size: 14px;
        transition: opacity 0.2s ease;
      }

      footer {
        padding: 14px;
        text-align: center;
        color: var(--muted);
        font-size: 13px;
      }

      a {
        color: inherit;
      }

      .hidden {
        display: none !important;
      }

      .sr-only {
        position: absolute;
        left: -9999px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        Cartes mémoire physique
        <select id="chapterSelect" aria-label="Choisir un chapitre">
          <!-- options générées dynamiquement -->
        </select>
      </h1>
      <div class="sub">
        Cliquez sur la carte pour la retourner. Utilisez ← / → pour naviguer,
        barre d'espace pour retourner.
      </div>
    </header>

    <main class="wrap">
      <section class="stage" id="stage" aria-label="Carte mémoire">
        <div class="skeleton-card" id="skeleton"></div>
        <div class="card-shell" id="cardShell">
          <div
            class="card3d"
            id="card3d"
            aria-live="polite"
            tabindex="0"
            role="button"
            aria-pressed="false"
          >
            <div class="face front">
              <img id="frontImg" alt="Recto de la carte" draggable="false" />
            </div>
            <div class="face back">
              <img id="backImg" alt="Verso de la carte" draggable="false" />
            </div>
          </div>
        </div>
      </section>

      <div class="controls">
        <button id="prevBtn" class="secondary" title="Précédent (←)">
          ← Précédent
        </button>
        <button id="flipBtn" title="Retourner (espace)">Retourner</button>
        <button id="nextBtn" class="secondary" title="Suivant (→)">
          Suivant →
        </button>

        <label class="toggle" title="Activer/désactiver l'ordre aléatoire">
          <span>Aléatoire</span>
          <span
            class="switch"
            id="shuffleSwitch"
            role="switch"
            aria-checked="false"
            tabindex="0"
          >
            <span class="knob"></span>
          </span>
        </label>
      </div>
      <div class="meta" id="counter">Chargement…</div>
    </main>

    <footer></footer>

    <script>
      /* ==========================
       Configuration
       ========================== */
      const CHAPTERS_MANUAL = [];
      const CHAPTER_PREFIX = "ch";
      const CHAPTER_SUFFIX = "_cartes";
      const MAX_CHAPTERS_PROBE = 20;
      const MAX_PROBE = 100;
      const PRELOAD_RADIUS = 2; // Only preload ±2 cards around current

      /* ===== Helpers ===== */
      const qs = (s, el = document) => el.querySelector(s);

      // Image cache to avoid redundant loads
      const imageCache = new Map();
      const loadingImages = new Map();

      function loadImage(url, useCache = true) {
        // Return cached promise if available
        if (useCache && imageCache.has(url)) {
          return Promise.resolve(imageCache.get(url));
        }

        // Return existing loading promise if in progress
        if (loadingImages.has(url)) {
          return loadingImages.get(url);
        }

        // Create new loading promise
        const promise = new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const result = {
              ok: true,
              width: img.naturalWidth,
              height: img.naturalHeight,
              src: url,
            };
            if (useCache) imageCache.set(url, result);
            loadingImages.delete(url);
            resolve(result);
          };
          img.onerror = () => {
            const result = { ok: false, src: url };
            loadingImages.delete(url);
            resolve(result);
          };
          img.src = url;
        });

        loadingImages.set(url, promise);
        return promise;
      }

      // Only use cache-busting for discovery
      function probeImage(url) {
        return loadImage(url + "?probe=" + Date.now(), false);
      }

      const frontURL = (n) => `${state.basePath}/front${n}.png`;
      const backURL = (n) => `${state.basePath}/back${n}.png`;

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      const state = {
        total: 0,
        deck: [],
        i: 0,
        flipped: false,
        shuffle: JSON.parse(localStorage.getItem("fc_shuffle") || "false"),
        chapter: null,
        basePath: "",
        sizes: {},
        isTransitioning: false,
        imagesLoaded: new Set(),
        manifest: null,
      };

      // Skeleton loader management
      function showSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.add("visible");
      }

      function hideSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.remove("visible");
      }

      async function discoverChapters() {
        if (CHAPTERS_MANUAL.length) return CHAPTERS_MANUAL.slice();
        const found = [];

        // Parallel discovery with batching
        const batchSize = 5;
        for (let start = 1; start <= MAX_CHAPTERS_PROBE; start += batchSize) {
          const batch = [];
          for (
            let n = start;
            n < Math.min(start + batchSize, MAX_CHAPTERS_PROBE + 1);
            n++
          ) {
            const p = `${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}/front1.png`;
            batch.push(probeImage(p).then((r) => (r.ok ? n : null)));
          }
          const results = await Promise.all(batch);
          const validChapters = results.filter((n) => n !== null);
          found.push(...validChapters);

          // Stop if we found a gap
          if (validChapters.length < batch.length) break;
        }

        return found;
      }

      function applyChapter(n) {
        state.chapter = n;
        state.basePath = `${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}`;
        localStorage.setItem("fc_chapter", String(n));
      }

      async function loadManifest() {
        state.manifest = null;
        const url = `${state.basePath}/manifest.json`;
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) return;
          const data = await res.json();
          state.manifest = data;
        } catch (_) {
          // Manifest is optional; ignore failures
          state.manifest = null;
        }
      }

      async function loadChapter(n) {
        showSkeleton();
        applyChapter(n);
        state.sizes = {};
        state.total = 0;
        state.deck = [];
        state.i = 0;
        state.imagesLoaded.clear();

        const total = await discoverPairs();
        state.total = total;

        // Try to load optional manifest for filtering
        await loadManifest();

        if (!total) {
          hideSkeleton();
          qs(
            "#counter"
          ).textContent = `Aucune image de carte trouvée dans "${state.basePath}".`;
          return;
        }

        rebuildDeck();
        if (!state.deck.length) {
          hideSkeleton();
          qs("#counter").textContent = "Aucune carte disponible.";
          return;
        }
        await showCurrent();
      }

      function buildChapterSelect(chapters) {
        const sel = qs("#chapterSelect");
        sel.innerHTML = "";
        chapters.forEach((n) => {
          const opt = document.createElement("option");
          opt.value = String(n);
          opt.textContent = `Chapitre ${n}`;
          sel.appendChild(opt);
        });
        const stored = parseInt(localStorage.getItem("fc_chapter") || "", 10);
        const initial = chapters.includes(stored) ? stored : chapters[0];
        sel.value = String(initial);
        sel.addEventListener("change", async (e) => {
          const val = parseInt(e.target.value, 10);
          await loadChapter(val);
        });
        return initial;
      }

      async function discoverPairs() {
        // Binary search for finding the last valid card
        let left = 1,
          right = MAX_PROBE,
          lastValid = 0;

        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          const [pf, pb] = await Promise.all([
            probeImage(frontURL(mid)),
            probeImage(backURL(mid)),
          ]);

          if (pf.ok && pb.ok) {
            lastValid = mid;
            state.sizes[mid] = { w: pf.width, h: pf.height };
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }

        // Fill in any gaps in the range [1, lastValid]
        if (lastValid > 0) {
          const checks = [];
          for (let k = 1; k <= lastValid; k++) {
            if (!state.sizes[k]) {
              checks.push(
                probeImage(frontURL(k)).then((pf) => {
                  if (pf.ok) {
                    state.sizes[k] = { w: pf.width, h: pf.height };
                  }
                })
              );
            }
          }
          await Promise.all(checks);
        }

        return lastValid;
      }

      function rebuildDeck(keepCardNo = null) {
        const { total, manifest } = state;
        let newDeck = Array.from({ length: total }, (_, i) => i + 1);

        // Exclude purple-tagged cards if manifest available
        if (manifest) {
          const purple = new Set();
          if (manifest.per_card && typeof manifest.per_card === "object") {
            for (const [k, v] of Object.entries(manifest.per_card)) {
              if (v && v.border === "purple") purple.add(parseInt(k, 10));
            }
          } else if (
            manifest.cards_by_border &&
            Array.isArray(manifest.cards_by_border.purple)
          ) {
            manifest.cards_by_border.purple.forEach((n) =>
              purple.add(parseInt(n, 10))
            );
          }
          if (purple.size) {
            newDeck = newDeck.filter((n) => !purple.has(n));
          }
        }

        if (state.shuffle) shuffleInPlace(newDeck);
        if (keepCardNo != null) {
          const idx = newDeck.indexOf(keepCardNo);
          state.deck = newDeck;
          state.i = Math.max(0, idx);
        } else {
          state.deck = newDeck;
          state.i = state.shuffle
            ? Math.floor(Math.random() * newDeck.length)
            : 0;
        }
      }

      function updateCounter() {
        const el = qs("#counter");
        if (!state.deck.length) {
          el.textContent = "Aucune image trouvée.";
          return;
        }
        const n = state.deck[state.i];
        el.textContent = `Carte ${n} sur ${state.deck.length} ${
          state.shuffle ? "(aléatoire)" : ""
        }`;
      }

      function setFlipped(on) {
        state.flipped = on;
        const card3d = qs("#card3d");
        card3d.classList.add("flipping");
        setTimeout(() => card3d.classList.remove("flipping"), 600);
        card3d.classList.toggle("flipped", on);
        card3d.setAttribute("aria-pressed", String(on));
      }

      function sizeStageForImage(naturalW, naturalH) {
        const stage = qs("#stage");
        const maxWidth = Math.min(window.innerWidth * 0.92, 1000);
        const maxHeight = window.innerHeight * 0.7;

        const widthByHeight = maxHeight * (naturalW / naturalH);
        const finalWidth = Math.min(maxWidth, widthByHeight);
        const finalHeight = finalWidth * (naturalH / naturalW);

        stage.style.width = `${finalWidth}px`;
        stage.style.height = `${finalHeight}px`;
      }

      function waitAnimationEnd(el, name, fallback = 600) {
        return new Promise((resolve) => {
          let done = false;
          const onEnd = (e) => {
            if (e.animationName === name) {
              done = true;
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          };
          el.addEventListener("animationend", onEnd);
          setTimeout(() => {
            if (!done) {
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          }, fallback);
        });
      }

      async function showCurrent(direction = "none") {
        if (state.isTransitioning) return;

        const n = state.deck[state.i];
        const size = state.sizes[n];
        if (size && size.w > 0 && size.h > 0) {
          sizeStageForImage(size.w, size.h);
        }

        const cardShell = qs("#cardShell");
        const card3d = qs("#card3d");
        const frontImg = qs("#frontImg");
        const backImg = qs("#backImg");

        // Show skeleton immediately if images not loaded
        const isFirstLoad = !state.imagesLoaded.has(n);
        if (isFirstLoad) {
          showSkeleton();
        }

        state.isTransitioning = true;

        // Helper to swap images while hidden
        const swapImages = async () => {
          if (state.flipped) {
            card3d.classList.add("no-anim");
            card3d.classList.remove("flipped", "flipping");
            card3d.setAttribute("aria-pressed", "false");
            state.flipped = false;
            void card3d.offsetHeight; // flush
            card3d.classList.remove("no-anim");
          }

          // Reset image loaded state (keep hidden until ready)
          frontImg.classList.remove("loaded");
          backImg.classList.remove("loaded");

          // Load images in parallel
          const [front, back] = await Promise.all([
            loadImage(frontURL(n)),
            loadImage(backURL(n)),
          ]);

          // Update sources
          frontImg.src = front.src;
          backImg.src = back.src;

          // Wait for ready-to-paint; try decode() first, fallback to onload
          try {
            if (frontImg.decode && backImg.decode) {
              await Promise.all([frontImg.decode(), backImg.decode()]);
            } else {
              await Promise.all([
                new Promise((resolve) => {
                  if (frontImg.complete) resolve();
                  else frontImg.onload = resolve;
                }),
                new Promise((resolve) => {
                  if (backImg.complete) resolve();
                  else backImg.onload = resolve;
                }),
              ]);
            }
          } catch (_) {
            // Fallback: ensure at least load events have fired
            await Promise.all([
              new Promise((resolve) => {
                if (frontImg.complete) resolve();
                else frontImg.onload = resolve;
              }),
              new Promise((resolve) => {
                if (backImg.complete) resolve();
                else backImg.onload = resolve;
              }),
            ]);
          }

          state.imagesLoaded.add(n);
          frontImg.classList.add("loaded");
          backImg.classList.add("loaded");
          hideSkeleton();
          updateCounter();
        };

        // No animation case (initial load or programmatic)
        if (direction === "none") {
          await swapImages();
          state.isTransitioning = false;
          preloadNearbyCards();
          return;
        }

        // Determine classes for out/in phases
        // Next: slide old left, bring new from right. Prev: opposite.
        const outClass = direction === "next" ? "out-left" : "out-right";
        const outName = direction === "next" ? "outLeft" : "outRight";
        const inClass = direction === "next" ? "in-right" : "in-left";
        const inName = direction === "next" ? "inRight" : "inLeft";

        // Clean previous animation classes, if any
        cardShell.classList.remove("out-left", "out-right", "in-left", "in-right");
        void cardShell.offsetWidth; // flush

        // Phase 1: animate out to fully hidden
        cardShell.classList.add(outClass);
        await waitAnimationEnd(cardShell, outName, 400);

        // Swap content while hidden
        await swapImages();

        // Phase 2: animate in to visible
        cardShell.classList.remove(outClass);
        void cardShell.offsetWidth; // flush
        cardShell.classList.add(inClass);
        await waitAnimationEnd(cardShell, inName, 500);
        cardShell.classList.remove(inClass);

        state.isTransitioning = false;

        // Smart preloading: only preload nearby cards
        preloadNearbyCards();
      }

      function preloadNearbyCards() {
        const { deck, i } = state;
        const preloadIndices = [];

        for (let offset = 1; offset <= PRELOAD_RADIUS; offset++) {
          preloadIndices.push(
            (i + offset) % deck.length,
            (i - offset + deck.length) % deck.length
          );
        }

        // Preload in background without blocking
        preloadIndices.forEach((idx) => {
          const k = deck[idx];
          if (k && !state.imagesLoaded.has(k)) {
            // Use requestIdleCallback for non-blocking preload
            if ("requestIdleCallback" in window) {
              requestIdleCallback(
                () => {
                  loadImage(frontURL(k));
                  loadImage(backURL(k));
                },
                { timeout: 2000 }
              );
            } else {
              setTimeout(() => {
                loadImage(frontURL(k));
                loadImage(backURL(k));
              }, 100);
            }
          }
        });
      }

      function nextCard() {
        if (state.isTransitioning) return;
        state.i = (state.i + 1) % state.deck.length;
        showCurrent("next");
      }

      function prevCard() {
        if (state.isTransitioning) return;
        state.i = (state.i - 1 + state.deck.length) % state.deck.length;
        showCurrent("prev");
      }

      function toggleShuffle() {
        state.shuffle = !state.shuffle;
        localStorage.setItem("fc_shuffle", JSON.stringify(state.shuffle));
        const keep = state.deck[state.i];
        rebuildDeck(keep);
        updateShuffleUI();
        showCurrent();
      }

      function updateShuffleUI() {
        const sw = qs("#shuffleSwitch");
        sw.classList.toggle("on", state.shuffle);
        sw.setAttribute("aria-checked", String(state.shuffle));
      }

      function bindUI() {
        const shell = qs("#cardShell");
        shell.addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });
        qs("#flipBtn").addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });
        qs("#nextBtn").addEventListener("click", nextCard);
        qs("#prevBtn").addEventListener("click", prevCard);

        const sw = qs("#shuffleSwitch");
        const toggler = () => toggleShuffle();
        sw.addEventListener("click", toggler);
        sw.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggler();
          }
        });

        window.addEventListener("keydown", (e) => {
          if (
            e.target &&
            ["INPUT", "TEXTAREA", "SELECT", "BUTTON"].includes(e.target.tagName)
          )
            return;
          if (e.key === "ArrowRight") nextCard();
          else if (e.key === "ArrowLeft") prevCard();
          else if (e.key === " ") {
            e.preventDefault();
            if (!state.isTransitioning) {
              setFlipped(!state.flipped);
            }
          } else if (e.key.toLowerCase() === "r" && !e.ctrlKey && !e.metaKey) {
            toggleShuffle();
          }
        });

        // Debounced resize handler
        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            const n = state.deck[state.i];
            const size = state.sizes[n];
            if (size) sizeStageForImage(size.w, size.h);
          }, 100);
        });
      }

      (async function init() {
        bindUI();
        updateShuffleUI();

        showSkeleton();
        const chapters = await discoverChapters();

        if (!chapters.length) {
          hideSkeleton();
          qs("#counter").textContent =
            "Aucun chapitre trouvé (dossier 'chN_cartes').";
          return;
        }

        const initial = buildChapterSelect(chapters);
        await loadChapter(initial);
      })();
    </script>
  </body>
</html>
