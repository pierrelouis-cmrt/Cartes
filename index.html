<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cartes mémoire physique</title>
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="a052a820-83ee-48c6-bf8a-9b3c2b3a8fd3"
    ></script>
    <style>
      :root {
        --bg: #f7f7f9;
        --fg: #0f172a;
        --muted: #6b7280;
        --accent: #111827;
        --btn: #111827;
        --btn-fg: #ffffff;
        /* Scale corner radius with container size, with sensible bounds */
        --radius: clamp(6px, 8%, 52px);
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.12);
        --shadow-active: 0 20px 60px rgba(0, 0, 0, 0.16);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
        display: grid;
        min-height: 100dvh;
        grid-template-rows: auto 1fr auto;
      }
      header {
        padding: 22px 20px 10px;
        text-align: center;
      }
      h1 {
        font-size: 22px;
        margin: 0 0 8px;
        letter-spacing: 0.2px;
      }
      .sub {
        color: var(--muted);
        font-size: 14px;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 10px 16px 22px;
        width: 100%;
      }

      /* Stage */
      .stage {
        position: relative;
        margin: 10px auto 18px;
        width: min(92vw, 1000px);
        perspective: 2000px;
        -webkit-perspective: 2000px;
        user-select: none;
        display: block;
      }

      /* Shell holds the 3D space */
      .card-shell {
        position: relative;
        width: 100%;
        height: 100%;
        cursor: pointer;
        transition: transform 0.15s ease-out, opacity 0.2s ease-out;
      }

      .card-shell:hover {
        transform: translateY(-2px);
      }

      .card-shell:active {
        transform: translateY(0px) scale(0.98);
      }

      /* Transition states for navigation */
      .card-shell.transitioning {
        animation: cardTransition 0.3s ease-out;
      }

      @keyframes cardTransition {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        40% {
          opacity: 0;
          transform: scale(0.95);
        }
        60% {
          opacity: 0;
          transform: scale(0.95);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* Alternative subtle slide animation */
      @keyframes slideTransition {
        0% {
          opacity: 1;
          transform: translateX(0);
        }
        40% {
          opacity: 0;
          transform: translateX(-10px);
        }
        60% {
          opacity: 0;
          transform: translateX(10px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .card-shell.slide-left {
        animation: slideTransitionLeft 0.3s ease-out;
      }

      @keyframes slideTransitionLeft {
        0% {
          opacity: 1;
          transform: translateX(0);
        }
        40% {
          opacity: 0;
          transform: translateX(-15px);
        }
        60% {
          opacity: 0;
          transform: translateX(15px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .card-shell.slide-right {
        animation: slideTransitionRight 0.3s ease-out;
      }

      @keyframes slideTransitionRight {
        0% {
          opacity: 1;
          transform: translateX(0);
        }
        40% {
          opacity: 0;
          transform: translateX(15px);
        }
        60% {
          opacity: 0;
          transform: translateX(-15px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Inner flipper with smooth animation */
      .card3d {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        -webkit-transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
          box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: rotateY(0deg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }

      /* Disable transitions when resetting orientation between cards */
      .card3d.no-anim {
        transition: none !important;
      }

      .card3d.flipping {
        box-shadow: var(--shadow-active);
      }

      .card3d.flipped {
        transform: rotateY(180deg);
      }

      .face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        border-radius: var(--radius);
        overflow: hidden;
        background: #ffffff;
        transition: opacity 0.3s ease-in-out;
      }

      .face.front {
        transform: rotateY(0deg);
      }

      .face.back {
        transform: rotateY(180deg);
      }

      .face img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #ffffff;
        pointer-events: none;
        opacity: 0;
        animation: fadeIn 0.3s ease-out forwards;
      }

      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      /* Controls with smooth transitions */
      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button,
      .toggle {
        appearance: none;
        border: 0;
        background: var(--btn);
        color: var(--btn-fg);
        padding: 12px 16px;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateY(0);
      }

      button:hover:not(:disabled),
      .toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      button:active:not(:disabled),
      .toggle:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }

      button.secondary {
        background: #e5e7eb;
        color: #111827;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
      }

      .switch {
        width: 42px;
        height: 26px;
        background: #e5e7eb;
        border-radius: 999px;
        position: relative;
        transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .knob {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background: #fff;
        border-radius: 999px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      .switch.on {
        background: #e5e7eb;
      }

      .switch.on .knob {
        left: 19px;
      }

      .meta {
        margin-top: 6px;
        text-align: center;
        color: var(--muted);
        font-size: 14px;
        transition: opacity 0.2s ease;
      }

      footer {
        padding: 14px;
        text-align: center;
        color: var(--muted);
        font-size: 13px;
      }

      a {
        color: inherit;
      }

      .hidden {
        display: none !important;
      }

      .sr-only {
        position: absolute;
        left: -9999px;
      }

      /* Loading state */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .loading {
        animation: pulse 1.5s ease-in-out infinite;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        Cartes mémoire physique
        <select id="chapterSelect" aria-label="Choisir un chapitre">
          <!-- options générées dynamiquement -->
        </select>
      </h1>
      <div class="sub">
        Cliquez sur la carte pour la retourner. Utilisez ← / → pour naviguer,
        barre d'espace pour retourner.
      </div>
    </header>

    <main class="wrap">
      <section class="stage" id="stage" aria-label="Carte mémoire">
        <div class="card-shell" id="cardShell">
          <div
            class="card3d"
            id="card3d"
            aria-live="polite"
            tabindex="0"
            role="button"
            aria-pressed="false"
          >
            <div class="face front">
              <img id="frontImg" alt="Recto de la carte" draggable="false" />
            </div>
            <div class="face back">
              <img id="backImg" alt="Verso de la carte" draggable="false" />
            </div>
          </div>
        </div>
      </section>

      <div class="controls">
        <button id="prevBtn" class="secondary" title="Précédent (←)">
          ← Précédent
        </button>
        <button id="flipBtn" title="Retourner (espace)">Retourner</button>
        <button id="nextBtn" class="secondary" title="Suivant (→)">
          Suivant →
        </button>

        <label class="toggle" title="Activer/désactiver l'ordre aléatoire">
          <span>Aléatoire</span>
          <span
            class="switch"
            id="shuffleSwitch"
            role="switch"
            aria-checked="false"
            tabindex="0"
          >
            <span class="knob"></span>
          </span>
        </label>
      </div>
      <div class="meta" id="counter">Chargement…</div>
    </main>

    <footer></footer>

    <script>
      /* ==========================
       Configuration
       ========================== */
      // Découverte auto des chapitres chN_cartes via front1.png
      // Si vous préférez gérer à la main, indiquez simplement les numéros ici :
      // Exemple: const CHAPTERS_MANUAL = [1, 2, 3];
      const CHAPTERS_MANUAL = [];
      const CHAPTER_PREFIX = "ch";
      const CHAPTER_SUFFIX = "_cartes";
      const MAX_CHAPTERS_PROBE = 20;
      const MAX_PROBE = 100; // nb max de cartes par chapitre à sonder

      /* ===== Helpers ===== */
      const qs = (s, el = document) => el.querySelector(s);

      function preloadImage(url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () =>
            resolve({
              ok: true,
              width: img.naturalWidth,
              height: img.naturalHeight,
            });
          img.onerror = () => resolve({ ok: false });
          // cache-bust only when probing/preloading to force existence checks
          img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        });
      }

      const frontURL = (n) => `${state.basePath}/front${n}.png`;
      const backURL = (n) => `${state.basePath}/back${n}.png`;

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      const state = {
        total: 0,
        deck: [],
        i: 0,
        flipped: false,
        shuffle: JSON.parse(localStorage.getItem("fc_shuffle") || "false"),
        chapter: null,
        basePath: "",
        sizes: {}, // { [n]: { w, h } } (based on front image)
        isTransitioning: false, // Add flag to prevent rapid navigation
      };

      async function discoverChapters() {
        if (CHAPTERS_MANUAL.length) return CHAPTERS_MANUAL.slice();
        const found = [];
        for (let n = 1; n <= MAX_CHAPTERS_PROBE; n++) {
          const p = `${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}/front1.png`;
          const r = await preloadImage(p);
          if (r.ok) found.push(n);
        }
        return found;
      }

      function applyChapter(n) {
        state.chapter = n;
        state.basePath = `${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}`;
        localStorage.setItem("fc_chapter", String(n));
      }

      async function loadChapter(n) {
        applyChapter(n);
        state.sizes = {};
        state.total = 0;
        state.deck = [];
        state.i = 0;
        const total = await discoverPairs();
        state.total = total;
        if (!total) {
          qs(
            "#counter"
          ).textContent = `Aucune image de carte trouvée dans "${state.basePath}". Placez des fichiers nommés front1.png, back1.png, … puis rechargez.`;
          return;
        }
        rebuildDeck();
        showCurrent();
      }

      function buildChapterSelect(chapters) {
        const sel = qs("#chapterSelect");
        sel.innerHTML = "";
        chapters.forEach((n) => {
          const opt = document.createElement("option");
          opt.value = String(n);
          opt.textContent = `Chapitre ${n}`;
          sel.appendChild(opt);
        });
        const stored = parseInt(localStorage.getItem("fc_chapter") || "", 10);
        const initial = chapters.includes(stored) ? stored : chapters[0];
        sel.value = String(initial);
        sel.addEventListener("change", async (e) => {
          const val = parseInt(e.target.value, 10);
          await loadChapter(val);
        });
        return initial;
      }

      async function discoverPairs() {
        let n = 0;
        for (let k = 1; k <= MAX_PROBE; k++) {
          const [pf, pb] = await Promise.all([
            preloadImage(frontURL(k)),
            preloadImage(backURL(k)),
          ]);
          if (pf.ok && pb.ok) {
            n = k;
            state.sizes[k] = { w: pf.width, h: pf.height };
          } else {
            break;
          }
        }
        return n;
      }

      function rebuildDeck(keepCardNo = null) {
        const { total } = state;
        let newDeck = Array.from({ length: total }, (_, i) => i + 1);
        if (state.shuffle) shuffleInPlace(newDeck);
        if (keepCardNo != null) {
          const idx = newDeck.indexOf(keepCardNo);
          state.deck = newDeck;
          state.i = Math.max(0, idx);
        } else {
          state.deck = newDeck;
          // If shuffle is enabled, start at a random index so the first card shown is random
          state.i = state.shuffle
            ? Math.floor(Math.random() * newDeck.length)
            : 0;
        }
      }

      function updateCounter() {
        const el = qs("#counter");
        if (!state.total) {
          el.textContent = "Aucune image trouvée.";
          return;
        }
        const n = state.deck[state.i];
        el.textContent = `Carte ${n} sur ${state.total} ${
          state.shuffle ? "(aléatoire)" : ""
        }`;
      }

      function setFlipped(on) {
        state.flipped = on;
        const card3d = qs("#card3d");

        // Add flipping class for enhanced shadow during animation
        card3d.classList.add("flipping");
        setTimeout(() => card3d.classList.remove("flipping"), 600);

        card3d.classList.toggle("flipped", on);
        card3d.setAttribute("aria-pressed", String(on));
      }

      // Size the stage to the image AR; ensures image == container size exactly
      function sizeStageForImage(naturalW, naturalH) {
        const stage = qs("#stage");
        const maxWidth = Math.min(window.innerWidth * 0.92, 1000);
        const maxHeight = Math.min(
          window.innerHeight * 0.7,
          window.innerHeight * 0.7
        );

        const widthByHeight = maxHeight * (naturalW / naturalH);
        const finalWidth = Math.min(maxWidth, widthByHeight);
        const finalHeight = finalWidth * (naturalH / naturalW);

        stage.style.width = `${finalWidth}px`;
        stage.style.height = `${finalHeight}px`;
      }

      function showCurrent(direction = "none") {
        if (state.isTransitioning) return;

        const n = state.deck[state.i];
        const size = state.sizes[n];
        if (size && size.w > 0 && size.h > 0) {
          sizeStageForImage(size.w, size.h);
        }

        const cardShell = qs("#cardShell");
        const card3d = qs("#card3d");
        const front = qs("#frontImg");
        const back = qs("#backImg");

        // Fade out counter briefly during transition
        const counter = qs("#counter");
        counter.style.opacity = "0.5";

        // Apply transition animation
        state.isTransitioning = true;

        // Remove all animation classes first
        cardShell.classList.remove(
          "transitioning",
          "slide-left",
          "slide-right"
        );

        // Choose animation based on navigation direction
        let animationClass = "transitioning"; // default scale animation
        if (direction === "next") {
          animationClass = "slide-right";
        } else if (direction === "prev") {
          animationClass = "slide-left";
        }

        // Apply animation
        void cardShell.offsetHeight; // Force reflow
        cardShell.classList.add(animationClass);

        // Reset card to front during the fade-out phase (at 40% of animation)
        setTimeout(() => {
          // Reset to front if was flipped
          if (state.flipped) {
            card3d.classList.add("no-anim");
            card3d.classList.remove("flipped", "flipping");
            card3d.setAttribute("aria-pressed", "false");
            state.flipped = false;
            void card3d.offsetHeight;
            card3d.classList.remove("no-anim");
          }

          // Update images while faded out
          front.src = frontURL(n);
          back.src = backURL(n);
          updateCounter();
        }, 120); // 40% of 300ms animation

        // Clean up after animation
        setTimeout(() => {
          cardShell.classList.remove(animationClass);
          counter.style.opacity = "1";
          state.isTransitioning = false;
        }, 300);

        // Preload neighbors and capture sizes if needed
        const next = state.deck[(state.i + 1) % state.deck.length];
        const prev =
          state.deck[(state.i - 1 + state.deck.length) % state.deck.length];
        [next, prev].forEach(async (k) => {
          if (!state.sizes[k]) {
            const pf = await preloadImage(frontURL(k));
            if (pf.ok) state.sizes[k] = { w: pf.width, h: pf.height };
          }
          preloadImage(frontURL(k));
          preloadImage(backURL(k));
        });
      }

      function nextCard() {
        if (state.isTransitioning) return;
        state.i = (state.i + 1) % state.deck.length;
        showCurrent("next");
      }

      function prevCard() {
        if (state.isTransitioning) return;
        state.i = (state.i - 1 + state.deck.length) % state.deck.length;
        showCurrent("prev");
      }

      function toggleShuffle() {
        state.shuffle = !state.shuffle;
        localStorage.setItem("fc_shuffle", JSON.stringify(state.shuffle));
        const keep = state.deck[state.i];
        rebuildDeck(keep);
        updateShuffleUI();
        showCurrent();
      }

      function updateShuffleUI() {
        const sw = qs("#shuffleSwitch");
        sw.classList.toggle("on", state.shuffle);
        sw.setAttribute("aria-checked", String(state.shuffle));
      }

      function bindUI() {
        const shell = qs("#cardShell");
        shell.addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });
        qs("#flipBtn").addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });
        qs("#nextBtn").addEventListener("click", nextCard);
        qs("#prevBtn").addEventListener("click", prevCard);

        const sw = qs("#shuffleSwitch");
        const toggler = () => toggleShuffle();
        sw.addEventListener("click", toggler);
        sw.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggler();
          }
        });

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (
            e.target &&
            ["INPUT", "TEXTAREA", "SELECT", "BUTTON"].includes(e.target.tagName)
          )
            return;
          if (e.key === "ArrowRight") nextCard();
          else if (e.key === "ArrowLeft") prevCard();
          else if (e.key === " ") {
            e.preventDefault();
            if (!state.isTransitioning) {
              setFlipped(!state.flipped);
            }
          } else if (e.key.toLowerCase() === "r" && !e.ctrlKey && !e.metaKey) {
            // Avoid toggling shuffle when user presses browser reload (Ctrl/Cmd+R)
            toggleShuffle();
          }
        });

        // Recompute on resize
        window.addEventListener("resize", () => {
          const n = state.deck[state.i];
          const size = state.sizes[n];
          if (size) sizeStageForImage(size.w, size.h);
        });
      }

      (async function init() {
        bindUI();
        updateShuffleUI();

        const chapters = await discoverChapters();
        if (!chapters.length) {
          qs("#counter").textContent =
            "Aucun chapitre trouvé (dossier 'chN_cartes'). Ajoutez des dossiers comme 'ch1_cartes' et rechargez, ou remplissez CHAPTERS_MANUAL.";
          return;
        }
        const initial = buildChapterSelect(chapters);
        await loadChapter(initial);
      })();
    </script>
  </body>
</html>
