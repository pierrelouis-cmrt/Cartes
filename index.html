<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cartes mémoire physique</title>
    <link rel="preconnect" href="https://cloud.umami.is" crossorigin />
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="a052a820-83ee-48c6-bf8a-9b3c2b3a8fd3"
    ></script>
    <style>
      :root {
        --bg: #ffffff;
        --fg: #0f0f0f;
        --muted: #6b7280;
        --accent: #111827;
        --btn: #0f0f0f;
        --btn-fg: #ffffff;
        --btn-hover: #2a2a2a;
        --border: #e5e7eb;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.12);
        --shadow-active: 0 20px 60px rgba(0, 0, 0, 0.16);
        --skeleton-bg: #f3f4f6;
        --skeleton-shine: #ffffff;
        --green: #22c55e;
        --orange: #fb923c;
        --red: #ef4444;
        --gray: #d1d5db;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 16px/1.6 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        overflow-x: hidden;
      }

      /* Main app container - exactly 100vh */
      .app-container {
        height: 100vh;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      /* Header */
      header {
        padding: 20px 24px 12px;
        border-bottom: 1px solid var(--border);
        background: var(--bg);
        z-index: 10;
      }

      .header-content {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        flex-wrap: wrap;
      }

      h1 {
        font-size: 20px;
        font-weight: 600;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      /* Chapter selector - styled as minimal dropdown */
      .chapter-select {
        appearance: none;
        background: var(--bg);
        border: 2px solid var(--border);
        padding: 6px 32px 6px 12px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        background-image: url("data:image/svg+xml,%3Csvg width='12' height='7' viewBox='0 0 12 7' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23111827' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
      }

      .chapter-select:hover {
        border-color: var(--accent);
      }

      .chapter-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(17, 24, 39, 0.1);
      }

      .help-text {
        color: var(--muted);
        font-size: 13px;
        margin: 0;
      }

      /* Main content area */
      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        min-height: 0;
      }

      /* Stage for card */
      .stage {
        position: relative;
        margin: 0 auto 24px;
        width: min(90vw, 900px);
        perspective: 2000px;
        -webkit-perspective: 2000px;
        user-select: none;
        display: block;
      }

      /* Skeleton loader */
      .skeleton-card {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--skeleton-bg);
        border-radius: 20px; /* Just for skeleton */
        overflow: hidden;
        opacity: 0;
        transition: opacity 0.2s ease-out;
      }

      .skeleton-card.visible {
        opacity: 1;
      }

      .skeleton-card::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          var(--skeleton-shine),
          transparent
        );
        animation: shimmer 1.5s infinite;
      }

      @keyframes shimmer {
        to {
          left: 100%;
        }
      }

      /* Card shell and 3D card (keeping your original animations) */
      .card-shell {
        position: relative;
        width: 100%;
        height: 100%;
        cursor: pointer;
        transition: transform 0.15s ease-out, opacity 0.2s ease-out;
        will-change: transform, opacity;
        contain: paint;
        transform: translateZ(0);
      }

      .card-shell:hover {
        transform: translateY(-2px);
      }

      .card-shell:active {
        transform: translateY(0px) scale(0.98);
      }

      .card-shell.out-left {
        animation: outLeft 140ms ease-out both;
      }
      .card-shell.in-right {
        animation: inRight 180ms ease-out both;
      }
      .card-shell.out-right {
        animation: outRight 140ms ease-out both;
      }
      .card-shell.in-left {
        animation: inLeft 180ms ease-out both;
      }

      @keyframes outLeft {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(-12px);
        }
      }
      @keyframes inRight {
        from {
          opacity: 0;
          transform: translateX(12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      @keyframes outRight {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(12px);
        }
      }
      @keyframes inLeft {
        from {
          opacity: 0;
          transform: translateX(-12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .card3d {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        -webkit-transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: rotateY(0deg);
        will-change: transform;
      }

      .card3d.no-anim {
        transition: none !important;
      }

      .card3d.flipping {
        /* No shadow during flip */
      }

      .card3d.flipped {
        transform: rotateY(180deg);
      }

      .face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        overflow: hidden;
        transition: opacity 0.3s ease-in-out;
      }

      .face.front {
        transform: rotateY(0deg);
      }

      .face.back {
        transform: rotateY(180deg);
      }

      .face img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease-out;
        will-change: opacity;
      }

      .face img.loaded {
        opacity: 1;
      }

      /* Controls section */
      .controls-wrapper {
        width: 100%;
        max-width: 720px;
        margin: 0 auto;
        padding: 0 20px;
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
      }

      /* Navigation buttons */
      .nav-buttons {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        appearance: none;
        border: 0;
        background: var(--btn);
        color: var(--btn-fg);
        padding: 12px 24px;
        border-radius: var(--radius);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
      }

      .btn:hover:not(:disabled) {
        background: var(--btn-hover);
        transform: translateY(-1px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      .btn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .btn.secondary {
        background: transparent;
        color: var(--fg);
        border: 2px solid var(--border);
      }

      .btn.secondary:hover:not(:disabled) {
        background: var(--fg);
        color: var(--bg);
        border-color: var(--fg);
      }

      .btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .btn-icon {
        width: 16px;
        height: 16px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .btn-flip {
        background: var(--accent);
        padding: 12px 32px;
      }

      /* Filter controls */
      .filter-controls {
        display: flex;
        gap: 24px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: center;
        /* Enlarge the overall tap/click target */
        padding: 6px 10px;
        border-radius: 12px;
        cursor: pointer;
        /* Prevent text selection on double click */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        /* Remove mobile tap highlight */
        -webkit-tap-highlight-color: transparent;
      }

      .filter-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--muted);
        font-weight: 600;
      }

      /* Traffic light pills for both timer and difficulty */
      .traffic-pills {
        display: flex;
        gap: 4px;
        cursor: pointer;
        padding: 6px;
        border-radius: 20px;
        transition: background 0.2s ease;
        align-items: center;
      }

      .traffic-pills:hover {
        background: rgba(0, 0, 0, 0.04);
      }

      .pill {
        width: 20px;
        height: 8px;
        border-radius: 4px;
        background: var(--gray);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      /* Timer states */
      .traffic-pills[data-level="green"] .pill:nth-child(1) {
        background: var(--green);
        box-shadow: 0 0 8px rgba(34, 197, 94, 0.4);
      }

      .traffic-pills[data-level="orange"] .pill:nth-child(1) {
        background: var(--green);
      }

      .traffic-pills[data-level="orange"] .pill:nth-child(2) {
        background: var(--orange);
        box-shadow: 0 0 8px rgba(251, 146, 60, 0.4);
      }

      /* Difficulty states - now with 3 pills */
      .traffic-pills[data-level="red"] .pill:nth-child(1) {
        background: var(--green);
      }

      .traffic-pills[data-level="red"] .pill:nth-child(2) {
        background: var(--orange);
      }

      .traffic-pills[data-level="red"] .pill:nth-child(3) {
        background: var(--red);
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
      }

      /* Remove old timer-clock and difficulty-pills styles */
      .timer-clock,
      .clock-face,
      .clock-center,
      .clock-hand,
      .minute-hand,
      .hour-hand,
      .difficulty-pills {
        /* These are being replaced */
      }

      /* Random Toggle */
      .random-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 14px;
        background: var(--bg);
        border: 2px solid var(--border);
        border-radius: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        user-select: none;
      }

      .random-toggle:hover {
        border-color: var(--accent);
        background: rgba(0, 0, 0, 0.02);
      }

      .random-toggle.active {
        background: var(--fg);
        color: var(--bg);
        border-color: var(--fg);
      }

      .random-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .random-icon svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .random-toggle.active .random-icon svg {
        transform: rotate(180deg);
      }

      .random-label {
        font-size: 13px;
        font-weight: 600;
      }

      /* Counter */
      .counter {
        margin-top: 16px;
        text-align: center;
        font-size: 14px;
        color: var(--muted);
        font-weight: 500;
      }

      /* Footer - scrollable below 100vh */
      .footer-section {
        background: var(--bg);
        border-top: 1px solid var(--border);
        padding: 40px 20px;
        min-height: 200px;
      }

      .footer-content {
        max-width: 800px;
        margin: 0 auto;
        text-align: center;
        color: var(--muted);
        font-size: 14px;
      }

      /* Responsive */
      @media (max-width: 640px) {
        .header-content {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }

        h1 {
          justify-content: center;
        }

        .filter-controls {
          gap: 20px;
        }

        .nav-buttons {
          flex-wrap: wrap;
          justify-content: center;
        }

      }

      /* Swap order only when width <= 507px
         so Retourner drops below while Prev/Next stay together */
      @media (max-width: 507px) {
        #prevBtn {
          order: 1;
        }
        #nextBtn {
          order: 2;
        }
        #flipBtn {
          order: 3;
        }
      }

      /* Hidden utility */
      .hidden {
        display: none !important;
      }

      .sr-only {
        position: absolute;
        left: -9999px;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <header>
        <div class="header-content">
          <h1>
            Cartes mémoire
            <select
              id="chapterSelect"
              class="chapter-select"
              aria-label="Choisir un chapitre"
            >
              <!-- options générées dynamiquement -->
            </select>
          </h1>
          <p class="help-text">← / → naviguer • Espace retourner</p>
        </div>
      </header>

      <main class="main-content">
        <section class="stage" id="stage" aria-label="Carte mémoire">
          <div class="skeleton-card" id="skeleton"></div>
          <div class="card-shell" id="cardShell">
            <div
              class="card3d"
              id="card3d"
              aria-live="polite"
              tabindex="0"
              role="button"
              aria-pressed="false"
            >
              <div class="face front">
                <img id="frontImg" alt="Recto de la carte" draggable="false" />
              </div>
              <div class="face back">
                <img id="backImg" alt="Verso de la carte" draggable="false" />
              </div>
            </div>
          </div>
        </section>

        <div class="controls-wrapper">
          <div class="controls">
            <div class="nav-buttons">
              <button
                id="prevBtn"
                class="btn secondary"
                title="Carte précédente (←)"
              >
                <svg class="btn-icon" viewBox="0 0 24 24">
                  <path d="M15 18l-6-6 6-6" />
                </svg>
                Précédent
              </button>

              <button
                id="flipBtn"
                class="btn btn-flip"
                title="Retourner la carte (Espace)"
              >
                Retourner
              </button>

              <button
                id="nextBtn"
                class="btn secondary"
                title="Carte suivante (→)"
              >
                Suivant
                <svg class="btn-icon" viewBox="0 0 24 24">
                  <path d="M9 18l6-6-6-6" />
                </svg>
              </button>
            </div>

            <div class="filter-controls">
              <div class="filter-group">
                <span class="filter-label">Timer</span>
                <div
                  class="traffic-pills"
                  id="timerFilter"
                  data-level="all"
                  role="button"
                  tabindex="0"
                  aria-label="Filtre timer"
                >
                  <div class="pill"></div>
                  <div class="pill"></div>
                </div>
              </div>

              <div class="filter-group">
                <span class="filter-label">Difficulté</span>
                <div
                  class="traffic-pills"
                  id="difficultyFilter"
                  data-level="all"
                  role="button"
                  tabindex="0"
                  aria-label="Filtre difficulté"
                >
                  <div class="pill"></div>
                  <div class="pill"></div>
                  <div class="pill"></div>
                </div>
              </div>

              <div
                class="random-toggle"
                id="randomToggle"
                role="switch"
                aria-checked="false"
                tabindex="0"
              >
                <div class="random-icon">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <rect width="12" height="12" x="2" y="10" rx="2" ry="2" />
                    <path
                      d="m17.92 14 3.5-3.5a2.24 2.24 0 0 0 0-3l-5-4.92a2.24 2.24 0 0 0-3 0L10 6"
                    />
                    <path d="M6 18h.01" />
                    <path d="M10 14h.01" />
                    <path d="M15 6h.01" />
                    <path d="M18 9h.01" />
                  </svg>
                </div>
                <span class="random-label">Aléatoire</span>
              </div>
            </div>

            <div class="counter" id="counter">Chargement…</div>
          </div>
        </div>
      </main>
    </div>

    <footer class="footer-section">
      <div class="footer-content">
        <!-- Votre contenu footer ici -->
      </div>
    </footer>

    <script>
      /* ==========================
       Configuration
       ========================== */
      const CHAPTERS_MANUAL = [];
      const CHAPTER_PREFIX = "ch";
      const CHAPTER_SUFFIX = "_cartes";
      const MAX_CHAPTERS_PROBE = 20;
      const MAX_PROBE = 100;
      const PRELOAD_RADIUS = 2;

      /* ===== Helpers ===== */
      const qs = (s, el = document) => el.querySelector(s);

      // Image cache to avoid redundant loads
      const imageCache = new Map();
      const loadingImages = new Map();

      function loadImage(url, useCache = true) {
        if (useCache && imageCache.has(url)) {
          return Promise.resolve(imageCache.get(url));
        }

        if (loadingImages.has(url)) {
          return loadingImages.get(url);
        }

        const promise = new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const result = {
              ok: true,
              width: img.naturalWidth,
              height: img.naturalHeight,
              src: url,
            };
            if (useCache) imageCache.set(url, result);
            loadingImages.delete(url);
            resolve(result);
          };
          img.onerror = () => {
            const result = { ok: false, src: url };
            loadingImages.delete(url);
            resolve(result);
          };
          img.src = url;
        });

        loadingImages.set(url, promise);
        return promise;
      }

      function probeImage(url) {
        return loadImage(url + "?probe=" + Date.now(), false);
      }

      const frontURL = (n) => `${state.basePath}/front${n}.png`;
      const backURL = (n) => `${state.basePath}/back${n}.png`;

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      const state = {
        total: 0,
        deck: [],
        i: 0,
        flipped: false,
        shuffle: JSON.parse(localStorage.getItem("fc_shuffle") || "false"),
        chapter: null,
        basePath: "",
        sizes: {},
        isTransitioning: false,
        imagesLoaded: new Set(),
        manifest: null,
        filterTimer: localStorage.getItem("fc_filter_timer") || "all",
        filterDifficulty: localStorage.getItem("fc_filter_diff") || "all",
      };

      // Timer states cycle
      const timerStates = ["all", "green", "orange"];
      const difficultyStates = ["all", "green", "orange", "red"];

      function showSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.add("visible");
      }

      function hideSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.remove("visible");
      }

      async function discoverChapters() {
        if (CHAPTERS_MANUAL.length) return CHAPTERS_MANUAL.slice();
        const found = [];

        const batchSize = 5;
        for (let start = 1; start <= MAX_CHAPTERS_PROBE; start += batchSize) {
          const batch = [];
          for (
            let n = start;
            n < Math.min(start + batchSize, MAX_CHAPTERS_PROBE + 1);
            n++
          ) {
            const p = `flashcards/${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}/front1.png`;
            batch.push(probeImage(p).then((r) => (r.ok ? n : null)));
          }
          const results = await Promise.all(batch);
          const validChapters = results.filter((n) => n !== null);
          found.push(...validChapters);

          if (validChapters.length < batch.length) break;
        }

        return found;
      }

      function applyChapter(n) {
        state.chapter = n;
        state.basePath = `flashcards/${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}`;
        localStorage.setItem("fc_chapter", String(n));
      }

      async function loadManifest() {
        state.manifest = null;
        const url = `${state.basePath}/manifest.json`;
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) return;
          const data = await res.json();
          state.manifest = data;
        } catch (_) {
          state.manifest = null;
        }
      }

      async function loadChapter(n) {
        showSkeleton();
        applyChapter(n);
        state.sizes = {};
        state.total = 0;
        state.deck = [];
        state.i = 0;
        state.imagesLoaded.clear();

        const total = await discoverPairs();
        state.total = total;

        await loadManifest();

        if (!total) {
          hideSkeleton();
          qs(
            "#counter"
          ).textContent = `Aucune image de carte trouvée dans "${state.basePath}".`;
          updateNavButtons();
          return;
        }

        rebuildDeck();
        if (!state.deck.length) {
          hideSkeleton();
          qs("#counter").textContent = "Aucune carte disponible.";
          updateNavButtons();
          return;
        }
        await showCurrent();
      }

      function buildChapterSelect(chapters) {
        const sel = qs("#chapterSelect");
        sel.innerHTML = "";
        chapters.forEach((n) => {
          const opt = document.createElement("option");
          opt.value = String(n);
          opt.textContent = `Chapitre ${n}`;
          sel.appendChild(opt);
        });
        const stored = parseInt(localStorage.getItem("fc_chapter") || "", 10);
        const initial = chapters.includes(stored) ? stored : chapters[0];
        sel.value = String(initial);
        sel.addEventListener("change", async (e) => {
          const val = parseInt(e.target.value, 10);
          await loadChapter(val);
        });
        return initial;
      }

      async function discoverPairs() {
        let left = 1,
          right = MAX_PROBE,
          lastValid = 0;

        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          const [pf, pb] = await Promise.all([
            probeImage(frontURL(mid)),
            probeImage(backURL(mid)),
          ]);

          if (pf.ok && pb.ok) {
            lastValid = mid;
            state.sizes[mid] = { w: pf.width, h: pf.height };
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }

        if (lastValid > 0) {
          const checks = [];
          for (let k = 1; k <= lastValid; k++) {
            if (!state.sizes[k]) {
              checks.push(
                probeImage(frontURL(k)).then((pf) => {
                  if (pf.ok) {
                    state.sizes[k] = { w: pf.width, h: pf.height };
                  }
                })
              );
            }
          }
          await Promise.all(checks);
        }

        return lastValid;
      }

      function rebuildDeck(keepCardNo = null) {
        const { total, manifest } = state;
        let newDeck = Array.from({ length: total }, (_, i) => i + 1);

        if (manifest) {
          const purple = new Set();
          if (manifest.per_card && typeof manifest.per_card === "object") {
            for (const [k, v] of Object.entries(manifest.per_card)) {
              if (v && v.border === "purple") purple.add(parseInt(k, 10));
            }
          } else if (
            manifest.cards_by_border &&
            Array.isArray(manifest.cards_by_border.purple)
          ) {
            manifest.cards_by_border.purple.forEach((n) =>
              purple.add(parseInt(n, 10))
            );
          }
          if (purple.size) {
            newDeck = newDeck.filter((n) => !purple.has(n));
          }

          const tf = state.filterTimer;
          if (tf && tf !== "all") {
            const allowedTimer = new Set();
            if (
              manifest.cards_by_timer &&
              Array.isArray(manifest.cards_by_timer[tf])
            ) {
              manifest.cards_by_timer[tf].forEach((n) =>
                allowedTimer.add(parseInt(n, 10))
              );
            } else if (
              manifest.per_card &&
              typeof manifest.per_card === "object"
            ) {
              for (const [k, v] of Object.entries(manifest.per_card)) {
                if (v && v.timer === tf) allowedTimer.add(parseInt(k, 10));
              }
            }
            if (allowedTimer.size) {
              newDeck = newDeck.filter((n) => allowedTimer.has(n));
            } else {
              newDeck = [];
            }
          }

          const df = state.filterDifficulty;
          if (df && df !== "all") {
            const allowedBorder = new Set();
            if (
              manifest.cards_by_border &&
              Array.isArray(manifest.cards_by_border[df])
            ) {
              manifest.cards_by_border[df].forEach((n) =>
                allowedBorder.add(parseInt(n, 10))
              );
            } else if (
              manifest.per_card &&
              typeof manifest.per_card === "object"
            ) {
              for (const [k, v] of Object.entries(manifest.per_card)) {
                if (v && v.border === df) allowedBorder.add(parseInt(k, 10));
              }
            }
            if (allowedBorder.size) {
              newDeck = newDeck.filter((n) => allowedBorder.has(n));
            } else {
              newDeck = [];
            }
          }
        }

        if (state.shuffle) shuffleInPlace(newDeck);
        if (keepCardNo != null) {
          const idx = newDeck.indexOf(keepCardNo);
          state.deck = newDeck;
          state.i = Math.max(0, idx);
        } else {
          state.deck = newDeck;
          state.i = state.shuffle
            ? Math.floor(Math.random() * newDeck.length)
            : 0;
        }
      }

      function updateCounter() {
        const el = qs("#counter");
        if (!state.deck.length) {
          el.textContent = "Aucune image trouvée.";
          return;
        }
        const position = Math.min(state.i + 1, state.deck.length);
        el.textContent = `Carte ${position} sur ${state.deck.length}`;
      }

      function setFlipped(on) {
        state.flipped = on;
        const card3d = qs("#card3d");
        card3d.classList.add("flipping");
        setTimeout(() => card3d.classList.remove("flipping"), 600);
        card3d.classList.toggle("flipped", on);
        card3d.setAttribute("aria-pressed", String(on));
      }

      function sizeStageForImage(naturalW, naturalH) {
        const stage = qs("#stage");
        const maxWidth = Math.min(window.innerWidth * 0.9, 900);
        const availableHeight = window.innerHeight - 300; // Leave room for controls
        const maxHeight = Math.max(availableHeight, 200);

        const widthByHeight = maxHeight * (naturalW / naturalH);
        const finalWidth = Math.min(maxWidth, widthByHeight);
        const finalHeight = finalWidth * (naturalH / naturalW);

        stage.style.width = `${finalWidth}px`;
        stage.style.height = `${finalHeight}px`;
      }

      function waitAnimationEnd(el, name, fallback = 600) {
        return new Promise((resolve) => {
          let done = false;
          const onEnd = (e) => {
            if (e.animationName === name) {
              done = true;
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          };
          el.addEventListener("animationend", onEnd);
          setTimeout(() => {
            if (!done) {
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          }, fallback);
        });
      }

      async function showCurrent(direction = "none") {
        if (state.isTransitioning) return;

        const n = state.deck[state.i];
        const size = state.sizes[n];
        if (size && size.w > 0 && size.h > 0) {
          sizeStageForImage(size.w, size.h);
        }

        const cardShell = qs("#cardShell");
        const card3d = qs("#card3d");
        const frontImg = qs("#frontImg");
        const backImg = qs("#backImg");

        const isFirstLoad = !state.imagesLoaded.has(n);
        if (isFirstLoad) {
          showSkeleton();
        }

        state.isTransitioning = true;

        const swapImages = async () => {
          if (state.flipped) {
            card3d.classList.add("no-anim");
            card3d.classList.remove("flipped", "flipping");
            card3d.setAttribute("aria-pressed", "false");
            state.flipped = false;
            void card3d.offsetHeight;
            card3d.classList.remove("no-anim");
          }

          frontImg.classList.remove("loaded");
          backImg.classList.remove("loaded");

          const [front, back] = await Promise.all([
            loadImage(frontURL(n)),
            loadImage(backURL(n)),
          ]);

          frontImg.src = front.src;
          backImg.src = back.src;

          try {
            if (frontImg.decode && backImg.decode) {
              await Promise.all([frontImg.decode(), backImg.decode()]);
            } else {
              await Promise.all([
                new Promise((resolve) => {
                  if (frontImg.complete) resolve();
                  else frontImg.onload = resolve;
                }),
                new Promise((resolve) => {
                  if (backImg.complete) resolve();
                  else backImg.onload = resolve;
                }),
              ]);
            }
          } catch (_) {
            await Promise.all([
              new Promise((resolve) => {
                if (frontImg.complete) resolve();
                else frontImg.onload = resolve;
              }),
              new Promise((resolve) => {
                if (backImg.complete) resolve();
                else backImg.onload = resolve;
              }),
            ]);
          }

          state.imagesLoaded.add(n);
          frontImg.classList.add("loaded");
          backImg.classList.add("loaded");
          hideSkeleton();
          updateCounter();
        };

        if (direction === "none") {
          await swapImages();
          updateNavButtons();
          state.isTransitioning = false;
          preloadNearbyCards();
          return;
        }

        const outClass = direction === "next" ? "out-left" : "out-right";
        const outName = direction === "next" ? "outLeft" : "outRight";
        const inClass = direction === "next" ? "in-right" : "in-left";
        const inName = direction === "next" ? "inRight" : "inLeft";

        cardShell.classList.remove(
          "out-left",
          "out-right",
          "in-left",
          "in-right"
        );
        void cardShell.offsetWidth;

        cardShell.classList.add(outClass);
        await waitAnimationEnd(cardShell, outName, 400);

        await swapImages();

        cardShell.classList.remove(outClass);
        void cardShell.offsetWidth;
        cardShell.classList.add(inClass);
        await waitAnimationEnd(cardShell, inName, 500);
        cardShell.classList.remove(inClass);

        state.isTransitioning = false;
        updateNavButtons();

        preloadNearbyCards();
      }

      function preloadNearbyCards() {
        const { deck, i } = state;
        const preloadIndices = [];

        for (let offset = 1; offset <= PRELOAD_RADIUS; offset++) {
          preloadIndices.push(
            (i + offset) % deck.length,
            (i - offset + deck.length) % deck.length
          );
        }

        preloadIndices.forEach((idx) => {
          const k = deck[idx];
          if (k && !state.imagesLoaded.has(k)) {
            if ("requestIdleCallback" in window) {
              requestIdleCallback(
                () => {
                  loadImage(frontURL(k));
                  loadImage(backURL(k));
                },
                { timeout: 2000 }
              );
            } else {
              setTimeout(() => {
                loadImage(frontURL(k));
                loadImage(backURL(k));
              }, 100);
            }
          }
        });
      }

      function nextCard() {
        if (state.isTransitioning) return;
        if (!state.deck.length || state.deck.length === 1) return;
        state.i = (state.i + 1) % state.deck.length;
        showCurrent("next");
      }

      function prevCard() {
        if (state.isTransitioning) return;
        if (!state.deck.length || state.deck.length === 1) return;
        state.i = (state.i - 1 + state.deck.length) % state.deck.length;
        showCurrent("prev");
      }

      function toggleShuffle() {
        state.shuffle = !state.shuffle;
        localStorage.setItem("fc_shuffle", JSON.stringify(state.shuffle));
        const keep = state.deck[state.i];
        rebuildDeck(keep);
        updateShuffleUI();
        showCurrent();
      }

      function updateShuffleUI() {
        const toggle = qs("#randomToggle");
        toggle.classList.toggle("active", state.shuffle);
        toggle.setAttribute("aria-checked", String(state.shuffle));
      }

      function updateNavButtons() {
        const disable = state.deck.length <= 1;
        const prev = qs("#prevBtn");
        const next = qs("#nextBtn");
        if (prev) prev.disabled = disable;
        if (next) next.disabled = disable;
      }

      function cycleTimer() {
        const currentIndex = timerStates.indexOf(state.filterTimer);
        const nextIndex = (currentIndex + 1) % timerStates.length;
        state.filterTimer = timerStates[nextIndex];
        localStorage.setItem("fc_filter_timer", state.filterTimer);
        updateTimerUI();

        const keep = state.deck[state.i];
        rebuildDeck(keep);
        if (!state.deck.length) {
          qs("#counter").textContent =
            "Aucune carte disponible pour ce filtre.";
          hideSkeleton();
          updateNavButtons();
          return;
        }
        showCurrent();
      }

      function updateTimerUI() {
        const pills = qs("#timerFilter");
        pills.setAttribute("data-level", state.filterTimer);
      }

      function cycleDifficulty() {
        const currentIndex = difficultyStates.indexOf(state.filterDifficulty);
        const nextIndex = (currentIndex + 1) % difficultyStates.length;
        state.filterDifficulty = difficultyStates[nextIndex];
        localStorage.setItem("fc_filter_diff", state.filterDifficulty);
        updateDifficultyUI();

        const keep = state.deck[state.i];
        rebuildDeck(keep);
        if (!state.deck.length) {
          qs("#counter").textContent =
            "Aucune carte disponible pour ce filtre.";
          hideSkeleton();
          updateNavButtons();
          return;
        }
        showCurrent();
      }

      function updateDifficultyUI() {
        const pills = qs("#difficultyFilter");
        pills.setAttribute("data-level", state.filterDifficulty);
      }

      function bindUI() {
        const shell = qs("#cardShell");
        shell.addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });

        qs("#flipBtn").addEventListener("click", () => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });

        qs("#nextBtn").addEventListener("click", nextCard);
        qs("#prevBtn").addEventListener("click", prevCard);

        // Random toggle
        const randomToggle = qs("#randomToggle");
        randomToggle.addEventListener("click", toggleShuffle);
        randomToggle.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggleShuffle();
          }
        });

        // Timer filter
        const timerFilter = qs("#timerFilter");
        timerFilter.addEventListener("click", cycleTimer);
        // Also allow clicking the whole group (incl. label)
        const timerGroup = timerFilter ? timerFilter.closest('.filter-group') : null;
        if (timerGroup) {
          timerGroup.addEventListener('click', (e) => {
            // Avoid double-trigger when clicking directly on the pills
            if (timerFilter.contains(e.target)) return;
            cycleTimer();
          });
        }
        timerFilter.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            cycleTimer();
          }
        });

        // Difficulty filter
        const diffFilter = qs("#difficultyFilter");
        diffFilter.addEventListener("click", cycleDifficulty);
        // Also allow clicking the whole group (incl. label)
        const diffGroup = diffFilter ? diffFilter.closest('.filter-group') : null;
        if (diffGroup) {
          diffGroup.addEventListener('click', (e) => {
            if (diffFilter.contains(e.target)) return;
            cycleDifficulty();
          });
        }
        diffFilter.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            cycleDifficulty();
          }
        });

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (
            e.target &&
            ["INPUT", "TEXTAREA", "SELECT", "BUTTON"].includes(e.target.tagName)
          )
            return;
          if (e.key === "ArrowRight") nextCard();
          else if (e.key === "ArrowLeft") prevCard();
          else if (e.key === " ") {
            e.preventDefault();
            if (!state.isTransitioning) {
              setFlipped(!state.flipped);
            }
          } else if (e.key.toLowerCase() === "r" && !e.ctrlKey && !e.metaKey) {
            toggleShuffle();
          }
        });

        // Debounced resize handler
        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            const n = state.deck[state.i];
            const size = state.sizes[n];
            if (size) sizeStageForImage(size.w, size.h);
          }, 100);
        });
      }

      // Sanitize stored filter values
      function sanitizeFilters() {
        const allowedTimers = new Set(["all", "green", "orange"]);
        if (!allowedTimers.has(state.filterTimer)) {
          state.filterTimer = "all";
          localStorage.setItem("fc_filter_timer", state.filterTimer);
        }

        const allowedDifficulties = new Set(["all", "green", "orange", "red"]);
        if (!allowedDifficulties.has(state.filterDifficulty)) {
          state.filterDifficulty = "all";
          localStorage.setItem("fc_filter_diff", state.filterDifficulty);
        }
      }

      (async function init() {
        sanitizeFilters();
        bindUI();
        updateShuffleUI();
        updateTimerUI();
        updateDifficultyUI();

        showSkeleton();
        const chapters = await discoverChapters();

        if (!chapters.length) {
          hideSkeleton();
          qs("#counter").textContent =
            "Aucun chapitre trouvé (dossier 'flashcards/chN_cartes').";
          return;
        }

        const initial = buildChapterSelect(chapters);
        await loadChapter(initial);
      })();
    </script>
  </body>
</html>
