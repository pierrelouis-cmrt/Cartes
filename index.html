<!DOCTYPE html>
<html lang="fr" translate="no" class="notranslate">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <!-- Disable browser auto-translation and support system color scheme -->
    <meta name="google" content="notranslate" />
    <meta http-equiv="Content-Language" content="fr" />
    <meta name="color-scheme" content="light dark" />
    <meta name="supported-color-schemes" content="light dark" />
    <meta name="theme-color" content="#ffffff" />
    <meta
      name="theme-color"
      content="#0b0f14"
      media="(prefers-color-scheme: dark)"
    />
    <title>Cartes mémoire physique</title>
    <link rel="preconnect" href="https://cloud.umami.is" crossorigin />
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="a052a820-83ee-48c6-bf8a-9b3c2b3a8fd3"
    ></script>
    <script>
      // Detect touch-capable devices early and flag the document
      (function () {
        try {
          var isTouch =
            "ontouchstart" in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0;
          if (isTouch) document.documentElement.classList.add("is-touch");
        } catch (_) {}
      })();
    </script>
    <style>
      :root {
        /* Allow UA to style built-in controls appropriately */
        color-scheme: light dark;
        /* Base (light) theme */
        --bg: #ffffff;
        --fg: #0f0f0f;
        --muted: #6b7280;
        --accent: #111827; /* used for highlights and fills */
        --btn: #0f0f0f;
        --btn-fg: #ffffff;
        --btn-hover: #2a2a2a;
        --border: #e5e7eb;
        --border-light: var(--border);
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.12);
        --shadow-active: 0 20px 60px rgba(0, 0, 0, 0.16);
        --skeleton-bg: #f3f4f6;
        --skeleton-shine: #ffffff;
        --green: #22c55e;
        --yellow: #facc15;
        --orange: #fb923c;
        --red: #ef4444;
        --gray: #d1d5db;
        --gold: #fbbf24;
        --gold-hover: #fcd34d;
        /* UI overlays */
        --glass: rgba(249, 250, 251, 0.7);
        --hover-bg: rgba(0, 0, 0, 0.04);
        --pill-bg: rgba(0, 0, 0, 0.03);
        --pill-border: rgba(0, 0, 0, 0.06);
        /* Card image filter (none for light mode) */
        --card-img-filter: none;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0b0f14; /* near black with slight blue */
          --fg: #e6e8ee; /* light foreground */
          --muted: #9aa3b2; /* muted text */
          --accent: #cbd5e1; /* slate-300 like */
          --btn: #e5e7eb; /* light button */
          --btn-fg: #0f1117; /* dark text on light button */
          --btn-hover: #cfd3d8; /* slightly darker on hover */
          --border: #1f2937; /* slate-800 border */
          --border-light: #374151; /* slate-700 border for lighter elements */
          --shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
          --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.55);
          --shadow-active: 0 20px 60px rgba(0, 0, 0, 0.6);
          --skeleton-bg: #111418;
          --skeleton-shine: #1a1f26;
          --gray: #374151;
          --yellow: #facc15;
          --gold: #f59e0b;
          --gold-hover: #fbbf24;
          --glass: rgba(11, 15, 20, 0.6);
          --hover-bg: rgba(255, 255, 255, 0.06);
          --pill-bg: rgba(255, 255, 255, 0.03);
          --pill-border: rgba(255, 255, 255, 0.08);
          /* Slightly dim card images to ease eye strain */
          --card-img-filter: brightness(0.9) saturate(0.96);
        }
      }

      html {
        -webkit-text-size-adjust: 100%;
        text-size-adjust: 100%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 16px/1.6 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        overflow-x: hidden;
      }

      /* Main app container - exactly 100vh */
      .app-container {
        height: 100vh;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      /* Header */
      header {
        padding: 0;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(to bottom, var(--bg) 0%, var(--glass) 100%);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        position: relative;
        z-index: 10;
      }

      header::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(17, 24, 39, 0.1) 20%,
          rgba(17, 24, 39, 0.1) 80%,
          transparent 100%
        );
      }

      .header-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 18px 24px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        flex-wrap: wrap;
      }

      h1 {
        font-size: 19px;
        font-weight: 600;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 14px;
        color: var(--fg);
        letter-spacing: -0.3px;
      }

      /* Chapter selector - more refined */
      .chapter-select {
        appearance: none;
        background: linear-gradient(135deg, var(--bg) 0%, var(--glass) 100%);
        border: 1.5px solid var(--border);
        padding: 7px 34px 7px 13px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 500;
        color: var(--fg);
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }

      .chapter-select:hover {
        border-color: var(--accent);
        background: var(--bg);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
      }

      .chapter-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(17, 24, 39, 0.08),
          0 2px 8px rgba(0, 0, 0, 0.06);
      }

      .help-text {
        color: var(--muted);
        font-size: 12px;
        margin: 0;
        padding: 4px 12px;
        background: rgba(107, 114, 128, 0.06);
        border-radius: 20px;
        font-weight: 500;
        letter-spacing: 0.2px;
      }

      /* Hide keyboard help on touch devices */
      .is-touch .help-text {
        display: none !important;
      }

      @media (max-width: 640px) {
        .header-content {
          padding: 14px 20px;
        }

        h1 {
          font-size: 17px;
          flex: 1 0 100%;
        }

        .help-text {
          font-size: 11px;
          padding: 3px 10px;
        }
      }

      /* Main content area */
      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        min-height: 0;
      }

      /* Stage for card */
      .stage {
        position: relative;
        margin: 0 auto 24px;
        width: min(90vw, 900px);
        perspective: 2000px;
        -webkit-perspective: 2000px;
        user-select: none;
        display: block;
      }

      /* Skeleton loader */
      .skeleton-card {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--skeleton-bg);
        border-radius: 20px; /* Just for skeleton */
        overflow: hidden;
        opacity: 0;
        transition: opacity 0.2s ease-out;
      }

      .skeleton-card.visible {
        opacity: 1;
      }

      .skeleton-card::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          var(--skeleton-shine),
          transparent
        );
        animation: shimmer 1.5s infinite;
      }

      @keyframes shimmer {
        to {
          left: 100%;
        }
      }

      /* Card shell and 3D card (keeping your original animations) */
      .card-shell {
        position: relative;
        width: 100%;
        height: 100%;
        cursor: pointer;
        transition: transform 0.15s ease-out, opacity 0.2s ease-out;
        will-change: transform, opacity;
        /* Allow floating controls (bookmark) to overflow */
        contain: layout;
        transform: translateZ(0);
      }

      .card-shell:hover {
        transform: translateY(-2px);
      }

      .card-shell:active {
        transform: translateY(0px) scale(0.98);
      }

      .card-shell.out-left {
        animation: outLeft 140ms ease-out both;
      }
      .card-shell.in-right {
        animation: inRight 180ms ease-out both;
      }
      .card-shell.out-right {
        animation: outRight 140ms ease-out both;
      }
      .card-shell.in-left {
        animation: inLeft 180ms ease-out both;
      }

      @keyframes outLeft {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(-12px);
        }
      }
      @keyframes inRight {
        from {
          opacity: 0;
          transform: translateX(12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      @keyframes outRight {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(12px);
        }
      }
      @keyframes inLeft {
        from {
          opacity: 0;
          transform: translateX(-12px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .card3d {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        -webkit-transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: rotateY(0deg);
        will-change: transform;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      .card3d.no-anim {
        transition: none !important;
      }

      .card3d.flipped {
        transform: rotateY(180deg);
      }

      .face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        overflow: hidden;
        transition: opacity 0.3s ease-in-out;
      }

      .face.front {
        transform: rotateY(0deg);
      }

      .face.back {
        transform: rotateY(180deg);
      }

      .face img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        opacity: 0;
        /* Smoothly apply dark-mode filter */
        transition: opacity 0.2s ease-out, filter 0.2s ease-out;
        filter: var(--card-img-filter);
        will-change: opacity;
      }

      .face img.loaded {
        opacity: 1;
      }

      /* Controls section */
      .controls-wrapper {
        width: 100%;
        max-width: 720px;
        margin: 0 auto;
        padding: 0 20px;
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
      }

      /* Navigation buttons */
      .nav-buttons {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        appearance: none;
        border: 0;
        background: var(--btn);
        color: var(--btn-fg);
        padding: 12px 24px;
        border-radius: var(--radius);
        font-size: 16px; /* Avoid iOS zoom on tap */
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
        min-height: 44px; /* Apple HIG minimum tap target */
        min-width: 44px;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation; /* Prevent double-tap zoom */
      }

      .btn:hover:not(:disabled) {
        background: var(--btn-hover);
        transform: translateY(-1px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      .btn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .btn.secondary {
        background: transparent;
        color: var(--fg);
        border: 2px solid var(--border);
      }

      .btn.secondary:hover:not(:disabled) {
        background: var(--fg);
        color: var(--bg);
        border-color: var(--fg);
      }

      .btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .btn-icon {
        width: 18px;
        height: 18px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      /* Bookmark button styles */
      .btn-bookmark {
        background: var(--accent);
        padding: 12px 32px;
        position: relative;
      }

      .btn-bookmark.active {
        background: var(--gold);
        border-color: var(--gold);
      }

      .btn-bookmark:hover:not(:disabled) {
        background: var(--accent);
      }

      .btn-bookmark svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        transition: all 0.2s ease;
      }

      .btn-bookmark.active svg {
        fill: currentColor;
      }

      .btn-bookmark.active:hover:not(:disabled) {
        background: var(--gold-hover);
        border-color: var(--gold-hover);
      }

      /* Filter controls */
      .filter-controls {
        display: flex;
        gap: 24px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: center;
        /* Enlarge the overall tap/click target */
        padding: 6px 10px;
        border-radius: 12px;
        cursor: pointer;
        /* Prevent text selection on double click */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        /* Remove mobile tap highlight */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }

      .toggle-pair {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: center;
      }

      .filter-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--muted);
        font-weight: 600;
      }

      /* Traffic light pills for both timer and difficulty */
      .traffic-pills {
        display: flex;
        gap: 4px;
        cursor: pointer;
        padding: 6px;
        border-radius: 20px;
        transition: background 0.2s ease;
        align-items: center;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }

      .filter-group:hover .traffic-pills {
        background: var(--hover-bg);
      }

      .pill {
        width: 20px;
        height: 8px;
        border-radius: 4px;
        background: var(--gray);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      /* Timer states */
      #timerFilter[data-level="green"] .pill:nth-child(1) {
        background: var(--green);
        box-shadow: 0 0 8px rgba(34, 197, 94, 0.4);
      }

      #timerFilter[data-level="yellow"] .pill:nth-child(1),
      #timerFilter[data-level="orange"] .pill:nth-child(1) {
        background: var(--green);
      }

      #timerFilter[data-level="yellow"] .pill:nth-child(2),
      #timerFilter[data-level="orange"] .pill:nth-child(2) {
        background: var(--yellow);
      }

      #timerFilter[data-level="yellow"] .pill:nth-child(2) {
        box-shadow: 0 0 8px rgba(250, 204, 21, 0.4);
      }

      #timerFilter[data-level="orange"] .pill:nth-child(3) {
        background: var(--orange);
        box-shadow: 0 0 8px rgba(251, 146, 60, 0.4);
      }

      /* Difficulty states - now with 3 pills */
      #difficultyFilter[data-level="green"] .pill:nth-child(1) {
        background: var(--green);
        box-shadow: 0 0 8px rgba(34, 197, 94, 0.4);
      }

      #difficultyFilter[data-level="orange"] .pill:nth-child(1),
      #difficultyFilter[data-level="red"] .pill:nth-child(1) {
        background: var(--green);
      }

      #difficultyFilter[data-level="orange"] .pill:nth-child(2),
      #difficultyFilter[data-level="red"] .pill:nth-child(2) {
        background: var(--orange);
        box-shadow: 0 0 8px rgba(251, 146, 60, 0.4);
      }

      #difficultyFilter[data-level="orange"] .pill:nth-child(3) {
        background: var(--gray);
        box-shadow: none;
      }

      #difficultyFilter[data-level="red"] .pill:nth-child(3) {
        background: var(--red);
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
      }

      /* Random Toggle */
      .random-toggle,
      .favourites-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 14px;
        background: var(--bg);
        border: 2px solid var(--border);
        border-radius: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        touch-action: manipulation;
      }

      .random-toggle:hover,
      .favourites-toggle:hover {
        border-color: var(--accent);
        background: var(--hover-bg);
      }

      .random-toggle.disabled {
        cursor: not-allowed;
        opacity: 0.6;
        color: var(--muted);
        background: var(--pill-bg);
        border-color: var(--border);
      }

      .random-toggle.disabled:hover {
        border-color: var(--border);
        background: var(--pill-bg);
      }

      .random-toggle.disabled .random-icon svg {
        stroke: currentColor;
      }

      .random-toggle.active,
      .favourites-toggle.active {
        background: var(--fg);
        color: var(--bg);
        border-color: var(--fg);
      }

      .favourites-toggle.active {
        background: var(--gold);
        color: var(--bg);
        border-color: var(--gold);
      }

      .random-icon,
      .favourites-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .random-icon svg,
      .favourites-icon svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .favourites-toggle.active .favourites-icon svg {
        fill: currentColor;
      }

      .random-toggle.active .random-icon svg {
        transform: rotate(180deg);
      }

      .random-label,
      .favourites-label {
        font-size: 13px;
        font-weight: 600;
      }

      .favourites-count {
        font-size: 11px;
        padding: 2px 6px;
        background: var(--pill-bg);
        border-radius: 10px;
        margin-left: 4px;
      }

      /* Counter */
      .counter {
        margin-top: 16px;
        text-align: center;
        font-size: 14px;
        color: var(--muted);
        font-weight: 500;
      }

      /* Footer - scrollable below 100vh */
      .footer-section {
        background: var(--bg);
        border-top: 1px solid var(--border);
        padding: 40px 20px;
        min-height: 200px;
      }

      .footer-content {
        max-width: 800px;
        margin: 0 auto;
        text-align: center;
        color: var(--muted);
        font-size: 14px;
      }

      /* Responsive */
      @media (max-width: 640px) {
        .header-content {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }

        h1 {
          justify-content: center;
        }

        .filter-controls {
          gap: 10px;
        }

        .nav-buttons {
          flex-wrap: wrap;
          justify-content: center;
        }
      }

      /* Small screens: keep button order, hide Prev/Next text */
      @media (max-width: 535px) {
        #prevBtn .btn-text,
        #nextBtn .btn-text {
          display: none;
        }
        .nav-buttons .btn {
          padding: 12px; /* compact but tappable */
        }
        /* .random-label,
        .favourites-label {
          display: none;
        }
        .favourites-count {
          display: none;
        } */
      }

      @media (max-width: 545px) {
        .filter-controls {
          justify-content: center;
        }

        .toggle-pair {
          flex: 1 0 100%;
          justify-content: center;
          width: 100%;
        }

        .toggle-pair .random-toggle,
        .toggle-pair .favourites-toggle {
          width: fit-content;
          max-width: fit-content;
        }
      }

      /* Ultra-small screens: text only for bookmark button */
      @media (max-width: 328px) {
        .filter-controls {
          gap: 0;
        }
        .filter-group {
          padding: 3px;
        }
        #bookmarkBtn .btn-text {
          display: none;
        }
        #bookmarkBtn {
          padding-left: 12px;
          padding-right: 12px;
        }
      }

      /* Hidden utility */
      .hidden {
        display: none !important;
      }

      .sr-only {
        position: absolute;
        left: -9999px;
      }

      /* Footer - Design créatif et moderne */
      .footer-section {
        border-top: 1px solid var(--border);
        /* Match header's background styling for consistency */
        background: linear-gradient(to top, var(--bg) 0%, var(--glass) 100%);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        position: relative;
        overflow: hidden;
      }

      /* (removed) Effet de gradient animé subtil */

      @keyframes footerGlow {
        0% {
          transform: translate(0, 0) scale(1);
        }
        100% {
          transform: translate(10%, -10%) scale(1.1);
        }
      }

      .footer-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 24px;
        flex-wrap: wrap;
        position: relative;
        z-index: 1;
      }

      /* Boutons à gauche avec un style pill */
      .footer-actions {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px;
        background: var(--pill-bg);
        border-radius: 14px;
        border: 1px solid var(--pill-border);
      }

      .icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        min-width: 32px;
        height: 32px;
        padding: 0 12px;
        border-radius: 8px;
        border: none;
        color: var(--muted);
        background: transparent;
        text-decoration: none;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        -webkit-tap-highlight-color: transparent;
      }

      .icon-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 8px;
        background: var(--accent);
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .icon-btn:hover {
        color: var(--btn-fg);
      }

      .icon-btn:hover::before {
        opacity: 1;
      }

      .icon-btn:active {
        transform: scale(0.96);
      }

      .icon-btn svg,
      .icon-btn-text {
        position: relative;
        z-index: 1;
      }

      .icon-btn svg {
        width: 16px;
        height: 16px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        flex-shrink: 0;
      }

      .icon-btn-text {
        display: none;
      }

      /* Texte du footer avec un design distinctif */
      .footer-text {
        flex: 1;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.7;
        text-align: left;
        position: relative;
        padding: 0 16px;
        max-width: 600px;
      }

      /* Style pour les liens en inline */
      .footer-text a {
        color: var(--fg);
        text-decoration: none;
        font-weight: 500;
        position: relative;
        transition: color 0.2s ease;
        white-space: nowrap;
      }

      .footer-text a::after {
        content: "";
        position: absolute;
        bottom: -1px;
        left: 0;
        right: 0;
        height: 1px;
        background: var(--accent);
        transform: scaleX(0);
        transform-origin: right;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .footer-text a:hover {
        color: var(--accent);
      }

      .footer-text a:hover::after {
        transform: scaleX(1);
        transform-origin: left;
      }

      /* (removed) Divider dots entre les éléments */

      /* Alternative: Layout vertical centré */
      @media (min-width: 641px) {
        .icon-btn-text {
          display: inline;
        }

        .footer-content {
          min-height: 80px;
        }
      }

      /* Mobile: Layout empilé et centré */
      @media (max-width: 640px) {
        .footer-content {
          flex-direction: column;
          gap: 16px;
          padding: 20px;
        }

        .footer-actions {
          order: 2;
          background: var(--pill-bg);
          padding: 4px;
        }

        .icon-btn-text {
          display: inline;
        }

        .footer-text {
          order: 1;
          padding: 0;
          text-align: center;
          max-width: 80%;
        }
      }

      /* Alternative créative: Variante avec badges pour les liens */
      .footer-text a {
        display: inline-block;
        padding: 1px 0;
      }

      /* Petite animation au chargement */
      .footer-section {
        animation: fadeInUp 0.4s ease-out;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <header>
        <div class="header-content">
          <h1>
            Cartes mémoire
            <select
              id="chapterSelect"
              class="chapter-select"
              aria-label="Choisir un chapitre"
            >
              <!-- options générées dynamiquement -->
            </select>
          </h1>
          <p class="help-text">
            ← / → pour naviguer • Espace pour retourner • R pour aléatoire • F
            pour favoris • B pour favori
          </p>
        </div>
      </header>

      <main class="main-content">
        <section class="stage" id="stage" aria-label="Carte mémoire">
          <div class="skeleton-card" id="skeleton"></div>
          <div class="card-shell" id="cardShell">
            <div
              class="card3d"
              id="card3d"
              aria-live="polite"
              tabindex="0"
              role="button"
              aria-pressed="false"
            >
              <div class="face front">
                <img id="frontImg" alt="Recto de la carte" draggable="false" />
              </div>
              <div class="face back">
                <img id="backImg" alt="Verso de la carte" draggable="false" />
              </div>
            </div>
          </div>
        </section>

        <div class="controls-wrapper">
          <div class="controls">
            <div class="nav-buttons">
              <button
                id="prevBtn"
                class="btn secondary"
                title="Carte précédente (←)"
                aria-label="Carte précédente"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  class="lucide lucide-arrow-left-icon lucide-arrow-left btn-icon"
                >
                  <path d="m12 19-7-7 7-7" />
                  <path d="M19 12H5" />
                </svg>
                <span class="btn-text">Précédent</span>
              </button>

              <button
                id="bookmarkBtn"
                class="btn btn-bookmark"
                title="Ajouter/retirer des favoris (B)"
                aria-label="Ajouter aux favoris"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  class="lucide lucide-bookmark-icon lucide-bookmark"
                >
                  <path
                    d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"
                  />
                </svg>
                <span class="btn-text">Ajouter</span>
              </button>

              <button
                id="nextBtn"
                class="btn secondary"
                title="Carte suivante (→)"
                aria-label="Carte suivante"
              >
                <span class="btn-text">Suivant</span>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  class="lucide lucide-arrow-right-icon lucide-arrow-right btn-icon"
                >
                  <path d="M5 12h14" />
                  <path d="m12 5 7 7-7 7" />
                </svg>
              </button>
            </div>

            <div class="filter-controls">
              <div class="filter-group">
                <span class="filter-label">Timer</span>
                <div
                  class="traffic-pills"
                  id="timerFilter"
                  data-level="all"
                  role="button"
                  tabindex="0"
                  aria-label="Filtre timer"
                >
                  <div class="pill"></div>
                  <div class="pill"></div>
                  <div class="pill"></div>
                </div>
              </div>

              <div class="filter-group">
                <span class="filter-label">Difficulté</span>
                <div
                  class="traffic-pills"
                  id="difficultyFilter"
                  data-level="all"
                  role="button"
                  tabindex="0"
                  aria-label="Filtre difficulté"
                >
                  <div class="pill"></div>
                  <div class="pill"></div>
                  <div class="pill"></div>
                </div>
              </div>

              <div class="toggle-pair">
                <div
                  class="random-toggle"
                  id="randomToggle"
                  role="switch"
                  aria-checked="false"
                  tabindex="0"
                >
                  <div class="random-icon">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="20"
                      height="20"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    >
                      <rect width="12" height="12" x="2" y="10" rx="2" ry="2" />
                      <path
                        d="m17.92 14 3.5-3.5a2.24 2.24 0 0 0 0-3l-5-4.92a2.24 2.24 0 0 0-3 0L10 6"
                      />
                      <path d="M6 18h.01" />
                      <path d="M10 14h.01" />
                      <path d="M15 6h.01" />
                      <path d="M18 9h.01" />
                    </svg>
                  </div>
                  <span class="random-label">Aléatoire</span>
                </div>

                <div
                  class="favourites-toggle"
                  id="favouritesToggle"
                  role="switch"
                  aria-checked="false"
                  tabindex="0"
                >
                  <div class="favourites-icon">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="20"
                      height="20"
                      viewBox="0 0 24 24"
                    >
                      <path
                        d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"
                      />
                    </svg>
                  </div>
                  <span class="favourites-label">Favoris</span>
                  <span class="favourites-count" id="favouritesCount">0</span>
                </div>
              </div>
            </div>

            <div class="counter" id="counter">Chargement…</div>
          </div>
        </div>
      </main>
    </div>

    <footer class="footer-section">
      <div class="footer-content">
        <div class="footer-actions">
          <a
            href="https://capecl.fr"
            class="icon-btn"
            aria-label="Accueil CAPECL"
            title="Accueil CAPECL"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-house-icon lucide-house"
            >
              <path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" />
              <path
                d="M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"
              />
            </svg>
            <span class="icon-btn-text">Accueil</span>
            <span class="sr-only">Accueil</span>
          </a>
          <a
            href="https://github.com/pierrelouis-cmrt/Cartes"
            class="icon-btn"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Dépôt GitHub"
            title="Dépôt GitHub"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-github-icon lucide-github"
            >
              <path
                d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"
              />
              <path d="M9 18c-4.51 2-5-2-7-2" />
            </svg>
            <span class="icon-btn-text">GitHub</span>
            <span class="sr-only">GitHub</span>
          </a>
        </div>

        <p class="footer-text">
          Site réalisé par
          <a
            href="https://pierrelouis.net"
            target="_blank"
            rel="noopener noreferrer"
            >Pierre-Louis</a
          >. Flashcards par B. Bernard, sous licence comme indiqué dans le
          <a
            href="https://github.com/pierrelouis-cmrt/Cartes#readme"
            target="_blank"
            rel="noopener noreferrer"
            >README</a
          >, et disponibles sur
          <a
            href="https://gitlab.com/capecl/y2"
            target="_blank"
            rel="noopener noreferrer"
            >GitLab</a
          >.
        </p>
      </div>
    </footer>

    <script>
      /* ==========================
 Configuration
 ========================== */
      const CHAPTERS_MANUAL = [];
      const CHAPTER_PREFIX = "ch";
      const CHAPTER_SUFFIX = "_cartes";
      const MAX_CHAPTERS_PROBE = 20;
      const MAX_PROBE = 100;
      const PRELOAD_RADIUS = 2;
      const MAX_HISTORY = 5; // Maximum history for shuffle mode

      /* ===== Helpers ===== */
      const qs = (s, el = document) => el.querySelector(s);

      // Image cache to avoid redundant loads
      const imageCache = new Map();
      const loadingImages = new Map();
      const manifestCache = new Map();
      const manifestFetches = new Map();
      const formatCacheByBase = new Map();

      function loadImage(url, useCache = true) {
        if (useCache && imageCache.has(url)) {
          return Promise.resolve(imageCache.get(url));
        }

        if (loadingImages.has(url)) {
          return loadingImages.get(url);
        }

        const promise = new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const result = {
              ok: true,
              width: img.naturalWidth,
              height: img.naturalHeight,
              src: url,
            };
            if (useCache) imageCache.set(url, result);
            loadingImages.delete(url);
            resolve(result);
          };
          img.onerror = () => {
            const result = { ok: false, src: url };
            loadingImages.delete(url);
            resolve(result);
          };
          img.src = url;
        });

        loadingImages.set(url, promise);
        return promise;
      }

      function probeImage(url) {
        const sep = url.includes("?") ? "&" : "?";
        return loadImage(`${url}${sep}probe=${Date.now()}`, false);
      }

      const IMAGE_FORMATS = ["webp", "png"];
      const imageFormatCache = new Map();

      function imageFormatCacheKey(basePath, prefix, n) {
        return `${basePath}|${prefix}|${n}`;
      }

      function buildImageURL(basePath, prefix, n, ext) {
        return `${basePath}/${prefix}${n}.${ext}`;
      }

      function normalizeExt(ext) {
        return typeof ext === "string" ? ext.trim().toLowerCase() : "";
      }

      function deriveFormatsFromManifest(manifest) {
        if (!manifest || typeof manifest !== "object") return null;
        const formats = {};
        const imgFormats = manifest.image_formats || manifest.formats;
        if (imgFormats && typeof imgFormats === "object") {
          if (imgFormats.front) formats.front = normalizeExt(imgFormats.front);
          if (imgFormats.back) formats.back = normalizeExt(imgFormats.back);
          if (imgFormats.default)
            formats.default = normalizeExt(imgFormats.default);
        }
        if (manifest.image_format) {
          const ext = normalizeExt(manifest.image_format);
          if (ext) {
            if (!formats.front) formats.front = ext;
            if (!formats.back) formats.back = ext;
            if (!formats.default) formats.default = ext;
          }
        }
        const keys = Object.keys(formats);
        if (!keys.length) return null;
        if (!formats.default) {
          if (formats.front && formats.back && formats.front === formats.back) {
            formats.default = formats.front;
          } else if (formats.front) {
            formats.default = formats.front;
          } else if (formats.back) {
            formats.default = formats.back;
          }
        }
        if (!formats.front && formats.default) formats.front = formats.default;
        if (!formats.back && formats.default) formats.back = formats.default;
        return formats;
      }

      function cacheFormatsForBase(basePath, manifest) {
        if (!basePath) return null;
        const derived = deriveFormatsFromManifest(manifest);
        if (derived) {
          formatCacheByBase.set(basePath, derived);
        }
        return derived;
      }

      function getPreferredFormats(prefix, basePath = state.basePath) {
        if (!basePath) return [];
        const formats =
          (basePath === state.basePath && state.formats) ||
          formatCacheByBase.get(basePath);
        if (!formats) return [];
        const ordered = [];
        if (formats[prefix]) ordered.push(formats[prefix]);
        if (formats.default) ordered.push(formats.default);
        return Array.from(new Set(ordered.filter(Boolean)));
      }

      function asPositiveInt(value) {
        const n = Number(value);
        return Number.isFinite(n) && n > 0 ? n : null;
      }

      async function fetchManifest(basePath, { forceReload = false } = {}) {
        if (!basePath) return null;
        if (!forceReload && manifestCache.has(basePath)) {
          return manifestCache.get(basePath);
        }
        if (manifestFetches.has(basePath)) {
          return manifestFetches.get(basePath);
        }
        const url = `${basePath}/manifest.json`;
        const fetchPromise = fetch(url, {
          cache: forceReload ? "reload" : "no-cache",
        })
          .then((res) => (res.ok ? res.json() : null))
          .catch(() => null)
          .then((data) => {
            manifestFetches.delete(basePath);
            if (data) {
              manifestCache.set(basePath, data);
              cacheFormatsForBase(basePath, data);
            }
            return data;
          });
        manifestFetches.set(basePath, fetchPromise);
        return fetchPromise;
      }

      function applyManifestMetadata(manifest) {
        const info = { total: 0, hasSizes: false, defaultSize: null };
        if (!manifest || typeof manifest !== "object") return info;

        if (Number.isFinite(manifest.total_cards)) {
          info.total = Number(manifest.total_cards);
        }

        const formats = cacheFormatsForBase(state.basePath, manifest);
        if (formats) {
          state.formats = formats;
        }

        let maxCard = info.total;
        let perCardSizeFound = false;

        if (manifest.per_card && typeof manifest.per_card === "object") {
          for (const [key, value] of Object.entries(manifest.per_card)) {
            const cardNo = asPositiveInt(key);
            if (!cardNo) continue;
            if (cardNo > maxCard) maxCard = cardNo;
            if (value && typeof value === "object") {
              let width = null;
              let height = null;
              if (value.front && typeof value.front === "object") {
                width = asPositiveInt(value.front.width);
                height = asPositiveInt(value.front.height);
              }
              if (!width || !height) {
                width = asPositiveInt(value.width);
                height = asPositiveInt(value.height);
              }
              if (width && height) {
                state.sizes[cardNo] = { w: width, h: height };
                perCardSizeFound = true;
              }
            }
          }
        }

        if (maxCard > info.total) info.total = maxCard;
        info.hasSizes = perCardSizeFound;

        const dims = manifest.card_dimensions;
        if (dims && typeof dims === "object") {
          const frontDims =
            dims.front && typeof dims.front === "object" ? dims.front : dims;
          const width = asPositiveInt(frontDims.width);
          const height = asPositiveInt(frontDims.height);
          if (width && height) {
            info.defaultSize = { w: width, h: height };
          }
        }

        return info;
      }

      async function loadCardImage(prefix, n, options = {}) {
        const {
          basePath = state.basePath,
          probe = false,
          useCache = true,
        } = options;

        if (!basePath) {
          return { ok: false, src: "" };
        }

        const key = imageFormatCacheKey(basePath, prefix, n);
        const cachedExt = imageFormatCache.get(key);
        const baseCandidates = getPreferredFormats(prefix, basePath);
        const candidateSet = [];
        if (cachedExt) candidateSet.push(cachedExt);
        baseCandidates.forEach((ext) => candidateSet.push(ext));
        IMAGE_FORMATS.forEach((ext) => candidateSet.push(ext));
        const candidates = Array.from(new Set(candidateSet.filter(Boolean)));
        if (!candidates.length) return { ok: false, src: "" };

        let lastTried = "";
        for (const ext of candidates) {
          const url = buildImageURL(basePath, prefix, n, ext);
          lastTried = url;
          const result = probe
            ? await probeImage(url)
            : await loadImage(url, useCache);
          if (result.ok) {
            imageFormatCache.set(key, ext);
            result.src = url;
            result.ext = ext;
            return result;
          }
        }

        return { ok: false, src: lastTried };
      }

      function loadFrontImage(n, options) {
        return loadCardImage("front", n, options);
      }

      function loadBackImage(n, options) {
        return loadCardImage("back", n, options);
      }

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      // Favourites management
      function getFavouritesKey() {
        return `fc_favourites_ch${state.chapter}`;
      }

      function loadFavourites() {
        const key = getFavouritesKey();
        const stored = localStorage.getItem(key);
        return stored ? new Set(JSON.parse(stored)) : new Set();
      }

      function saveFavourites(favourites) {
        const key = getFavouritesKey();
        localStorage.setItem(key, JSON.stringify(Array.from(favourites)));
        updateFavouritesCount();
      }

      function toggleFavourite(cardNo) {
        const favourites = loadFavourites();
        if (favourites.has(cardNo)) {
          favourites.delete(cardNo);
        } else {
          favourites.add(cardNo);
        }
        saveFavourites(favourites);
        return favourites.has(cardNo);
      }

      function updateFavouritesCount() {
        const count = loadFavourites().size;
        const countEl = qs("#favouritesCount");
        if (countEl) countEl.textContent = count.toString();
      }

      function updateBookmarkButton() {
        const btn = qs("#bookmarkBtn");
        if (!btn) return;
        const currentCard = getCurrentCard();
        const favourites = loadFavourites();
        const isFavourite = favourites.has(currentCard);
        btn.classList.toggle("active", isFavourite);
        btn.setAttribute("aria-pressed", String(isFavourite));
        const textEl = btn.querySelector(".btn-text");
        if (textEl) {
          textEl.textContent = isFavourite ? "Retirer" : "Ajouter";
        }
        btn.setAttribute(
          "aria-label",
          isFavourite ? "Retirer des favoris" : "Ajouter aux favoris"
        );
      }

      // History management for shuffle mode
      function getHistoryKey() {
        return `fc_history_ch${state.chapter}`;
      }

      function saveHistory() {
        if (!state.shuffle || !state.chapter) return;
        const key = getHistoryKey();
        // Only save up to MAX_HISTORY items
        const toSave = state.history.slice(-MAX_HISTORY);
        localStorage.setItem(key, JSON.stringify(toSave));
      }

      function loadHistory() {
        if (!state.chapter) return [];
        const key = getHistoryKey();
        const stored = localStorage.getItem(key);
        if (!stored) return [];
        try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
            // Filter to only include cards that are in current deck
            return parsed
              .filter((card) => state.deck.includes(card))
              .slice(-MAX_HISTORY);
          }
        } catch (_) {}
        return [];
      }

      function clearHistory() {
        if (!state.chapter) return;
        const key = getHistoryKey();
        localStorage.removeItem(key);
      }

      const state = {
        total: 0,
        deck: [], // All available cards (filtered)
        history: [], // Cards visited in order (for shuffle mode)
        historyIndex: -1, // Current position in history (for shuffle mode)
        currentIndex: 0, // Current position in deck (for sequential mode)
        unvisited: new Set(), // Cards not yet visited in shuffle mode
        flipped: false,
        shuffle: JSON.parse(localStorage.getItem("fc_shuffle") || "false"),
        showFavouritesOnly: false,
        chapter: null,
        basePath: "",
        sizes: {},
        isTransitioning: false,
        imagesLoaded: new Set(),
        preloading: new Set(),
        manifest: null,
        filterTimer: "all",
        filterDifficulty: "all",
        formats: null,
        shuffleQueue: [],
      };

      const LAST_CARD_KEY_PREFIX = "fc_last_card_";

      function shuffleArray(items) {
        const arr = items.slice();
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function ensureShuffleQueue(currentCard) {
        if (!state.shuffle) return;

        if (!Array.isArray(state.shuffleQueue)) {
          state.shuffleQueue = [];
        }

        if (state.shuffleQueue.length === 0) {
          if (state.unvisited.size === 0) {
            state.unvisited = new Set(state.deck);
            if (currentCard) state.unvisited.delete(currentCard);
          }

          const pool = Array.from(state.unvisited);
          state.shuffleQueue = shuffleArray(pool);
        }
      }

      function getStoredCard(chapter) {
        if (!chapter) return null;
        const raw = localStorage.getItem(`${LAST_CARD_KEY_PREFIX}${chapter}`);
        const parsed = parseInt(raw, 10);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function storeCurrentCard(cardNo) {
        if (!state.chapter || !cardNo) return;
        try {
          localStorage.setItem(
            `${LAST_CARD_KEY_PREFIX}${state.chapter}`,
            String(cardNo)
          );
        } catch (_) {}
      }

      function getCurrentCard() {
        if (state.shuffle) {
          // In shuffle mode, use history
          if (state.history.length === 0) return null;
          if (
            state.historyIndex < 0 ||
            state.historyIndex >= state.history.length
          )
            return null;
          return state.history[state.historyIndex];
        } else {
          // In sequential mode, use deck index
          if (state.deck.length === 0) return null;
          if (state.currentIndex < 0 || state.currentIndex >= state.deck.length)
            return null;
          return state.deck[state.currentIndex];
        }
      }

      // Timer states cycle
      const timerStates = ["all", "green", "yellow", "orange"];
      const difficultyStates = ["all", "green", "orange", "red"];

      function showSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.add("visible");
      }

      function hideSkeleton() {
        const skeleton = qs("#skeleton");
        skeleton.classList.remove("visible");
      }

      async function discoverChapters() {
        if (CHAPTERS_MANUAL.length) return CHAPTERS_MANUAL.slice();
        const found = [];

        const batchSize = 5;
        for (let start = 1; start <= MAX_CHAPTERS_PROBE; start += batchSize) {
          const batch = [];
          for (
            let n = start;
            n < Math.min(start + batchSize, MAX_CHAPTERS_PROBE + 1);
            n++
          ) {
            const basePath = `flashcards/${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}`;
            batch.push(
              (async () => {
                const manifest = await fetchManifest(basePath).catch(
                  () => null
                );
                if (manifest) return n;
                const probe = await loadFrontImage(1, { basePath });
                return probe.ok ? n : null;
              })()
            );
          }
          const results = await Promise.all(batch);
          const validChapters = results.filter((n) => n !== null);
          found.push(...validChapters);

          if (validChapters.length < batch.length) break;
        }

        return found;
      }

      function applyChapter(n) {
        state.chapter = n;
        state.basePath = `flashcards/${CHAPTER_PREFIX}${n}${CHAPTER_SUFFIX}`;
        state.formats = formatCacheByBase.get(state.basePath) || null;
        updateFavouritesCount();
      }

      async function loadManifest(options = {}) {
        state.manifest = null;
        if (!state.basePath) {
          state.formats = null;
          return { manifest: null, info: { total: 0, hasSizes: false } };
        }
        const manifest = await fetchManifest(state.basePath, options);
        state.manifest = manifest;
        state.formats = formatCacheByBase.get(state.basePath) || state.formats;
        const info = applyManifestMetadata(manifest);
        if (info.defaultSize && info.total) {
          for (let i = 1; i <= info.total; i++) {
            if (!state.sizes[i]) {
              state.sizes[i] = { ...info.defaultSize };
            }
          }
          info.hasSizes = true;
        }
        return { manifest, info };
      }

      async function loadChapter(n) {
        showSkeleton();
        applyChapter(n);
        state.sizes = {};
        state.total = 0;
        state.deck = [];
        state.history = [];
        state.historyIndex = -1;
        state.currentIndex = 0;
        state.unvisited.clear();
        state.shuffleQueue = [];
        state.imagesLoaded.clear();
        state.preloading.clear();
        state.formats = formatCacheByBase.get(state.basePath) || null;

        const { info } = await loadManifest();
        let total = info.total || 0;
        let hasSizes = info.hasSizes;

        if (!total) {
          total = await discoverPairs();
          hasSizes = true;
        } else if (!hasSizes && total > 0) {
          await ensureCardSizes(total);
          hasSizes = true;
        }

        state.total = total;

        if (!total) {
          hideSkeleton();
          qs(
            "#counter"
          ).textContent = `Aucune image de carte trouvée dans "${state.basePath}".`;
          updateNavButtons();
          return;
        }

        const storedCard = getStoredCard(state.chapter);
        rebuildDeck(storedCard);
        if (!state.deck.length) {
          hideSkeleton();
          qs("#counter").textContent = "Aucune carte disponible.";
          updateNavButtons();
          return;
        }

        // Initialize based on mode
        if (state.shuffle) {
          // Load saved history
          const savedHistory = loadHistory();
          if (savedHistory.length > 0) {
            state.history = savedHistory;
            state.historyIndex = savedHistory.length - 1;
            // Update unvisited set
            state.unvisited = new Set(state.deck);
            savedHistory.forEach((card) => state.unvisited.delete(card));
            state.shuffleQueue = [];
          } else if (storedCard && state.deck.includes(storedCard)) {
            state.history = [storedCard];
            state.historyIndex = 0;
            state.unvisited = new Set(state.deck);
            state.unvisited.delete(storedCard);
            state.shuffleQueue = [];
          } else {
            // Start with a random card
            const randomIdx = Math.floor(Math.random() * state.deck.length);
            const firstCard = state.deck[randomIdx];
            state.history = [firstCard];
            state.historyIndex = 0;
            state.unvisited = new Set(state.deck);
            state.unvisited.delete(firstCard);
            state.shuffleQueue = [];
          }
        } else {
          // Sequential mode
          if (storedCard && state.deck.includes(storedCard)) {
            state.currentIndex = state.deck.indexOf(storedCard);
          } else {
            state.currentIndex = 0;
          }
        }

        ensureShuffleQueue(getCurrentCard());
        await showCurrent();
      }

      function buildChapterSelect(chapters) {
        const sel = qs("#chapterSelect");
        sel.innerHTML = "";
        chapters.forEach((n) => {
          const opt = document.createElement("option");
          opt.value = String(n);
          opt.textContent = `Chapitre ${n}`;
          sel.appendChild(opt);
        });
        const defaultChapter = chapters[chapters.length - 1];
        const initial = defaultChapter;
        sel.value = String(initial);
        sel.addEventListener("change", async (e) => {
          const val = parseInt(e.target.value, 10);
          await loadChapter(val);
        });
        return initial;
      }

      async function discoverPairs() {
        let left = 1,
          right = MAX_PROBE,
          lastValid = 0;

        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          const [pf, pb] = await Promise.all([
            loadFrontImage(mid),
            loadBackImage(mid),
          ]);

          if (pf.ok && pb.ok) {
            lastValid = mid;
            state.sizes[mid] = { w: pf.width, h: pf.height };
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }

        if (lastValid > 0) {
          const checks = [];
          for (let k = 1; k <= lastValid; k++) {
            if (!state.sizes[k]) {
              checks.push(
                loadFrontImage(k).then((pf) => {
                  if (pf.ok) {
                    state.sizes[k] = { w: pf.width, h: pf.height };
                  }
                })
              );
            }
          }
          await Promise.all(checks);
        }

        return lastValid;
      }

      async function ensureCardSizes(total) {
        if (!total) return;
        const pending = [];
        for (let k = 1; k <= total; k++) {
          if (!state.sizes[k]) pending.push(k);
        }
        const batchSize = 6;
        while (pending.length) {
          const slice = pending.splice(0, batchSize);
          await Promise.all(
            slice.map((cardNo) =>
              loadFrontImage(cardNo).then((pf) => {
                if (pf.ok && pf.width && pf.height) {
                  state.sizes[cardNo] = { w: pf.width, h: pf.height };
                }
              })
            )
          );
        }
      }

      function rebuildDeck(keepCardNo = null) {
        const { total, manifest } = state;
        let newDeck = null;

        if (
          manifest &&
          manifest.per_card &&
          typeof manifest.per_card === "object"
        ) {
          const numbers = Array.from(
            new Set(
              Object.keys(manifest.per_card)
                .map((key) => asPositiveInt(key))
                .filter(Boolean)
            )
          ).sort((a, b) => a - b);
          if (numbers.length) {
            newDeck = numbers;
          }
        }

        if (!newDeck) {
          newDeck = Array.from({ length: total }, (_, i) => i + 1);
        } else if (total && newDeck.length < total) {
          const existing = new Set(newDeck);
          for (let i = 1; i <= total; i++) {
            if (!existing.has(i)) newDeck.push(i);
          }
        }

        if (manifest) {
          const purple = new Set();
          if (manifest.per_card && typeof manifest.per_card === "object") {
            for (const [k, v] of Object.entries(manifest.per_card)) {
              if (v && v.border === "purple") purple.add(parseInt(k, 10));
            }
          } else if (
            manifest.cards_by_border &&
            Array.isArray(manifest.cards_by_border.purple)
          ) {
            manifest.cards_by_border.purple.forEach((n) =>
              purple.add(parseInt(n, 10))
            );
          }
          if (purple.size) {
            newDeck = newDeck.filter((n) => !purple.has(n));
          }

          const tf = state.filterTimer;
          if (tf && tf !== "all") {
            const allowedTimer = new Set();
            if (
              manifest.cards_by_timer &&
              Array.isArray(manifest.cards_by_timer[tf])
            ) {
              manifest.cards_by_timer[tf].forEach((n) =>
                allowedTimer.add(parseInt(n, 10))
              );
            } else if (
              manifest.per_card &&
              typeof manifest.per_card === "object"
            ) {
              for (const [k, v] of Object.entries(manifest.per_card)) {
                if (v && v.timer === tf) allowedTimer.add(parseInt(k, 10));
              }
            }
            if (allowedTimer.size) {
              newDeck = newDeck.filter((n) => allowedTimer.has(n));
            } else {
              newDeck = [];
            }
          }

          const df = state.filterDifficulty;
          if (df && df !== "all") {
            const allowedBorder = new Set();
            if (
              manifest.cards_by_border &&
              Array.isArray(manifest.cards_by_border[df])
            ) {
              manifest.cards_by_border[df].forEach((n) =>
                allowedBorder.add(parseInt(n, 10))
              );
            } else if (
              manifest.per_card &&
              typeof manifest.per_card === "object"
            ) {
              for (const [k, v] of Object.entries(manifest.per_card)) {
                if (v && v.border === df) allowedBorder.add(parseInt(k, 10));
              }
            }
            if (allowedBorder.size) {
              newDeck = newDeck.filter((n) => allowedBorder.has(n));
            } else {
              newDeck = [];
            }
          }
        }

        // Apply favourites filter if active
        if (state.showFavouritesOnly) {
          const favourites = loadFavourites();
          newDeck = newDeck.filter((n) => favourites.has(n));
        }

        // Sort the deck deterministically (don't shuffle here)
        newDeck.sort((a, b) => a - b);

        state.deck = newDeck;

        // Reset position based on mode
        if (state.shuffle) {
          // In shuffle mode, update history if needed
          if (keepCardNo != null && newDeck.includes(keepCardNo)) {
            // Keep the card in history
            if (!state.history.includes(keepCardNo)) {
              state.history = [keepCardNo];
              state.historyIndex = 0;
            }
          } else {
            // Filter history to only include cards still in deck
            state.history = state.history.filter((card) =>
              newDeck.includes(card)
            );
            if (state.history.length === 0 && newDeck.length > 0) {
              // Pick a random card to start
              const randomIdx = Math.floor(Math.random() * newDeck.length);
              state.history = [newDeck[randomIdx]];
              state.historyIndex = 0;
            } else {
              state.historyIndex = Math.min(
                state.historyIndex,
                state.history.length - 1
              );
            }
          }
          // Update unvisited set
          state.unvisited = new Set(newDeck);
          state.history.forEach((card) => state.unvisited.delete(card));
          state.shuffleQueue = [];
        } else {
          // Sequential mode
          if (keepCardNo != null && newDeck.includes(keepCardNo)) {
            state.currentIndex = newDeck.indexOf(keepCardNo);
          } else {
            state.currentIndex = 0;
          }
        }
      }

      function updateCounter() {
        const el = qs("#counter");
        if (!state.deck.length) {
          if (state.showFavouritesOnly) {
            el.textContent = "Aucun favori disponible.";
          } else {
            el.textContent = "Aucune image trouvée.";
          }
          return;
        }

        const currentCard = getCurrentCard();
        if (!currentCard) {
          el.textContent = "Aucune carte sélectionnée.";
          return;
        }

        if (state.showFavouritesOnly) {
          const position = state.deck.indexOf(currentCard);
          const displayNumber =
            position >= 0 ? position + 1 : currentCard || "?";
          el.textContent = `Favori ${displayNumber} sur ${state.deck.length}`;
        } else {
          el.textContent = `Carte n°${currentCard}, ${state.deck.length} résultats`;
        }
      }

      function setFlipped(on) {
        state.flipped = on;
        const card3d = qs("#card3d");
        card3d.classList.add("flipping");
        setTimeout(() => card3d.classList.remove("flipping"), 600);
        card3d.classList.toggle("flipped", on);
        card3d.setAttribute("aria-pressed", String(on));
      }

      function sizeStageForImage(naturalW, naturalH) {
        const stage = qs("#stage");
        const maxWidth = Math.min(window.innerWidth * 0.9, 900);
        const availableHeight = window.innerHeight - 300; // Leave room for controls
        const maxHeight = Math.max(availableHeight, 200);

        const widthByHeight = maxHeight * (naturalW / naturalH);
        const finalWidth = Math.min(maxWidth, widthByHeight);
        const finalHeight = finalWidth * (naturalH / naturalW);

        stage.style.width = `${finalWidth}px`;
        stage.style.height = `${finalHeight}px`;
      }

      function waitAnimationEnd(el, name, fallback = 600) {
        return new Promise((resolve) => {
          let done = false;
          const onEnd = (e) => {
            if (e.animationName === name) {
              done = true;
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          };
          el.addEventListener("animationend", onEnd);
          setTimeout(() => {
            if (!done) {
              el.removeEventListener("animationend", onEnd);
              resolve();
            }
          }, fallback);
        });
      }

      async function showCurrent(direction = "none") {
        if (state.isTransitioning) return;

        const n = getCurrentCard();
        if (!n) return;

        const size = state.sizes[n];
        if (size && size.w > 0 && size.h > 0) {
          sizeStageForImage(size.w, size.h);
        }

        const cardShell = qs("#cardShell");
        const card3d = qs("#card3d");
        const frontImg = qs("#frontImg");
        const backImg = qs("#backImg");

        const isFirstLoad = !state.imagesLoaded.has(n);
        if (isFirstLoad) {
          showSkeleton();
        }

        state.isTransitioning = true;

        const swapImages = async () => {
          if (state.flipped) {
            card3d.classList.add("no-anim");
            card3d.classList.remove("flipped", "flipping");
            card3d.setAttribute("aria-pressed", "false");
            state.flipped = false;
            void card3d.offsetHeight;
            card3d.classList.remove("no-anim");
          }

          frontImg.classList.remove("loaded");
          backImg.classList.remove("loaded");

          const [front, back] = await Promise.all([
            loadFrontImage(n),
            loadBackImage(n),
          ]);

          if (front && front.ok && front.width && front.height) {
            state.sizes[n] = { w: front.width, h: front.height };
            sizeStageForImage(front.width, front.height);
          } else if (back && back.ok && back.width && back.height) {
            state.sizes[n] = { w: back.width, h: back.height };
            sizeStageForImage(back.width, back.height);
          }

          frontImg.src = front.src;
          backImg.src = back.src;

          try {
            if (frontImg.decode && backImg.decode) {
              await Promise.all([frontImg.decode(), backImg.decode()]);
            } else {
              await Promise.all([
                new Promise((resolve) => {
                  if (frontImg.complete) resolve();
                  else frontImg.onload = resolve;
                }),
                new Promise((resolve) => {
                  if (backImg.complete) resolve();
                  else backImg.onload = resolve;
                }),
              ]);
            }
          } catch (_) {
            await Promise.all([
              new Promise((resolve) => {
                if (frontImg.complete) resolve();
                else frontImg.onload = resolve;
              }),
              new Promise((resolve) => {
                if (backImg.complete) resolve();
                else backImg.onload = resolve;
              }),
            ]);
          }

          state.imagesLoaded.add(n);
          frontImg.classList.add("loaded");
          backImg.classList.add("loaded");
          hideSkeleton();
          updateCounter();
          updateBookmarkButton();
        };

        if (direction === "none") {
          await swapImages();
          updateNavButtons();
          state.isTransitioning = false;
          if (n) {
            storeCurrentCard(n);
          }
          preloadNearbyCards();
          return;
        }

        const outClass = direction === "next" ? "out-left" : "out-right";
        const outName = direction === "next" ? "outLeft" : "outRight";
        const inClass = direction === "next" ? "in-right" : "in-left";
        const inName = direction === "next" ? "inRight" : "inLeft";

        cardShell.classList.remove(
          "out-left",
          "out-right",
          "in-left",
          "in-right"
        );
        void cardShell.offsetWidth;

        cardShell.classList.add(outClass);
        await waitAnimationEnd(cardShell, outName, 400);

        await swapImages();

        cardShell.classList.remove(outClass);
        void cardShell.offsetWidth;
        cardShell.classList.add(inClass);
        await waitAnimationEnd(cardShell, inName, 500);
        cardShell.classList.remove(inClass);

        state.isTransitioning = false;
        updateNavButtons();

        if (n) {
          storeCurrentCard(n);
        }

        preloadNearbyCards();
      }

      function queuePreload(cardNo) {
        if (!cardNo) return;
        if (state.imagesLoaded.has(cardNo)) return;
        if (state.preloading.has(cardNo)) return;

        const startLoad = () => {
          const frontPromise = loadFrontImage(cardNo).then((front) => {
            if (front && front.ok && front.width && front.height) {
              state.sizes[cardNo] = { w: front.width, h: front.height };
            }
          });
          const backPromise = loadBackImage(cardNo);
          Promise.all([frontPromise, backPromise])
            .catch(() => {})
            .finally(() => {
              state.preloading.delete(cardNo);
            });
        };

        state.preloading.add(cardNo);

        if ("requestIdleCallback" in window) {
          requestIdleCallback(
            () => {
              startLoad();
            },
            { timeout: 1500 }
          );
        } else {
          setTimeout(() => {
            startLoad();
          }, 120);
        }
      }

      function preloadNearbyCards() {
        // Preload based on what might be shown next
        if (state.shuffle) {
          // In shuffle mode, preload a few random unvisited cards
          const unvisitedArray = Array.from(state.unvisited);
          const toPreload = Math.min(PRELOAD_RADIUS, unvisitedArray.length);
          for (let i = 0; i < toPreload; i++) {
            const randomIdx = Math.floor(Math.random() * unvisitedArray.length);
            queuePreload(unvisitedArray[randomIdx]);
          }

          // Also preload cards in history near current position
          for (let offset = 1; offset <= PRELOAD_RADIUS; offset++) {
            if (state.historyIndex - offset >= 0) {
              queuePreload(state.history[state.historyIndex - offset]);
            }
            if (state.historyIndex + offset < state.history.length) {
              queuePreload(state.history[state.historyIndex + offset]);
            }
          }
        } else {
          // In sequential mode, preload next and previous cards
          for (let offset = 1; offset <= PRELOAD_RADIUS; offset++) {
            const nextIdx = (state.currentIndex + offset) % state.deck.length;
            const prevIdx =
              (state.currentIndex - offset + state.deck.length) %
              state.deck.length;
            if (state.deck[nextIdx]) queuePreload(state.deck[nextIdx]);
            if (state.deck[prevIdx]) queuePreload(state.deck[prevIdx]);
          }
        }
      }

      function nextCard() {
        if (state.isTransitioning) return;
        if (!state.deck.length) return;

        if (state.shuffle) {
          // Shuffle mode: use history

          // Check if we're navigating forward in history
          if (state.historyIndex < state.history.length - 1) {
            // We have forward history, go to next in history
            state.historyIndex++;
            saveHistory();
            showCurrent("next");
            return;
          }

          // We're at the end of history, need to add a new card
          const current = getCurrentCard();
          let nextCardNo = null;

          ensureShuffleQueue(current);

          if (state.shuffleQueue.length > 0) {
            nextCardNo = state.shuffleQueue.pop();
          } else if (state.deck.length > 0) {
            // Edge case: only one card or queue exhausted unexpectedly
            nextCardNo = state.deck[0];
          }

          if (nextCardNo != null) {
            // Add to history (limit to MAX_HISTORY)
            state.history.push(nextCardNo);
            if (state.history.length > MAX_HISTORY) {
              state.history.shift();
              state.historyIndex = MAX_HISTORY - 1;
            } else {
              state.historyIndex++;
            }

            // Remove from unvisited
            state.unvisited.delete(nextCardNo);
            ensureShuffleQueue(nextCardNo);

            saveHistory();
            showCurrent("next");
          }
        } else {
          // Sequential mode: just go to next in deck
          state.currentIndex = (state.currentIndex + 1) % state.deck.length;
          showCurrent("next");
        }
      }

      function prevCard() {
        if (state.isTransitioning) return;
        if (!state.deck.length) return;

        if (state.shuffle) {
          // Shuffle mode: go back in history
          if (state.historyIndex > 0) {
            state.historyIndex--;
            showCurrent("prev");
          }
        } else {
          // Sequential mode: always enabled, go to previous in deck
          state.currentIndex =
            (state.currentIndex - 1 + state.deck.length) % state.deck.length;
          showCurrent("prev");
        }
      }

      function toggleShuffle() {
        if (state.showFavouritesOnly && !state.shuffle) {
          return;
        }
        state.shuffle = !state.shuffle;
        localStorage.setItem("fc_shuffle", JSON.stringify(state.shuffle));

        if (state.shuffle) {
          // Switching TO shuffle mode
          const currentCard = getCurrentCard();

          // Load saved history or start fresh
          const savedHistory = loadHistory();
          if (
            savedHistory.length > 0 &&
            savedHistory[savedHistory.length - 1] === currentCard
          ) {
            // Use saved history if it ends with current card
            state.history = savedHistory;
            state.historyIndex = savedHistory.length - 1;
          } else {
            // Start fresh history with current card
            state.history = currentCard ? [currentCard] : [];
            state.historyIndex = currentCard ? 0 : -1;
          }

          // Initialize unvisited set
          state.unvisited = new Set(state.deck);
          state.history.forEach((card) => state.unvisited.delete(card));
          state.shuffleQueue = [];

          saveHistory();
        } else {
          // Switching TO sequential mode
          clearHistory(); // Clear saved history
          const currentCard = getCurrentCard();
          if (currentCard) {
            state.currentIndex = state.deck.indexOf(currentCard);
            if (state.currentIndex === -1) state.currentIndex = 0;
          }
          state.shuffleQueue = [];
        }

        ensureShuffleQueue(getCurrentCard());
        updateShuffleUI();
        updateCounter();
        updateNavButtons();
      }

      function toggleFavouritesOnly() {
        state.showFavouritesOnly = !state.showFavouritesOnly;
        let keep = getCurrentCard();

        if (state.showFavouritesOnly && state.shuffle) {
          toggleShuffle();
          keep = getCurrentCard();
        }

        rebuildDeck(keep);
        updateFavouritesUI();
        updateShuffleUI();

        if (!state.deck.length) {
          qs("#counter").textContent = "Aucun favori disponible.";
          hideSkeleton();
          updateNavButtons();
          return;
        }
        showCurrent();
      }

      function updateShuffleUI() {
        const toggle = qs("#randomToggle");
        if (!toggle) return;
        const disabled = state.showFavouritesOnly;
        toggle.classList.toggle("active", state.shuffle);
        toggle.classList.toggle("disabled", disabled);
        toggle.setAttribute("aria-checked", String(state.shuffle));
        toggle.setAttribute("aria-disabled", String(disabled));
        toggle.setAttribute("tabindex", disabled ? "-1" : "0");
      }

      function updateFavouritesUI() {
        const toggle = qs("#favouritesToggle");
        if (!toggle) return;
        toggle.classList.toggle("active", state.showFavouritesOnly);
        toggle.setAttribute("aria-checked", String(state.showFavouritesOnly));
      }

      function updateNavButtons() {
        const prev = qs("#prevBtn");
        const next = qs("#nextBtn");

        if (state.shuffle) {
          // In shuffle mode: disable prev only if at beginning of history
          if (prev) prev.disabled = state.historyIndex <= 0;
        } else {
          // In sequential mode: prev is always enabled (wraps around)
          if (prev) prev.disabled = false;
        }

        // Next is disabled only if deck is empty
        if (next) next.disabled = state.deck.length === 0;
      }

      function cycleTimer() {
        const currentIndex = timerStates.indexOf(state.filterTimer);
        const nextIndex = (currentIndex + 1) % timerStates.length;
        state.filterTimer = timerStates[nextIndex];
        updateTimerUI();

        const keep = getCurrentCard();
        rebuildDeck(keep);
        if (!state.deck.length) {
          qs("#counter").textContent =
            "Aucune carte disponible pour ce filtre.";
          hideSkeleton();
          updateNavButtons();
          return;
        }
        showCurrent();
      }

      function updateTimerUI() {
        const pills = qs("#timerFilter");
        pills.setAttribute("data-level", state.filterTimer);
      }

      function cycleDifficulty() {
        const currentIndex = difficultyStates.indexOf(state.filterDifficulty);
        const nextIndex = (currentIndex + 1) % difficultyStates.length;
        state.filterDifficulty = difficultyStates[nextIndex];
        updateDifficultyUI();

        const keep = getCurrentCard();
        rebuildDeck(keep);
        if (!state.deck.length) {
          qs("#counter").textContent =
            "Aucune carte disponible pour ce filtre.";
          hideSkeleton();
          updateNavButtons();
          return;
        }
        showCurrent();
      }

      function updateDifficultyUI() {
        const pills = qs("#difficultyFilter");
        pills.setAttribute("data-level", state.filterDifficulty);
      }

      function bindUI() {
        const shell = qs("#cardShell");
        shell.addEventListener("click", (e) => {
          if (!state.isTransitioning) {
            setFlipped(!state.flipped);
          }
        });

        // Bookmark button
        const bookmarkBtn = qs("#bookmarkBtn");
        if (bookmarkBtn) {
          bookmarkBtn.addEventListener("click", (e) => {
            const currentCard = getCurrentCard();
            if (currentCard) {
              toggleFavourite(currentCard);
              updateBookmarkButton();
            }
          });
        }

        qs("#nextBtn").addEventListener("click", nextCard);
        qs("#prevBtn").addEventListener("click", prevCard);

        // Random toggle
        const randomToggle = qs("#randomToggle");
        if (randomToggle) {
          randomToggle.addEventListener("click", () => {
            if (randomToggle.classList.contains("disabled")) return;
            toggleShuffle();
          });
          randomToggle.addEventListener("keydown", (e) => {
            if (randomToggle.classList.contains("disabled")) return;
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              toggleShuffle();
            }
          });
        }

        // Favourites toggle
        const favouritesToggle = qs("#favouritesToggle");
        if (favouritesToggle) {
          favouritesToggle.addEventListener("click", toggleFavouritesOnly);
          favouritesToggle.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              toggleFavouritesOnly();
            }
          });
        }

        // Timer filter
        const timerFilter = qs("#timerFilter");
        timerFilter.addEventListener("click", cycleTimer);
        // Also allow clicking the whole group (incl. label)
        const timerGroup = timerFilter
          ? timerFilter.closest(".filter-group")
          : null;
        if (timerGroup) {
          timerGroup.addEventListener("click", (e) => {
            // Avoid double-trigger when clicking directly on the pills
            if (timerFilter.contains(e.target)) return;
            cycleTimer();
          });
        }
        timerFilter.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            cycleTimer();
          }
        });

        // Difficulty filter
        const diffFilter = qs("#difficultyFilter");
        diffFilter.addEventListener("click", cycleDifficulty);
        // Also allow clicking the whole group (incl. label)
        const diffGroup = diffFilter
          ? diffFilter.closest(".filter-group")
          : null;
        if (diffGroup) {
          diffGroup.addEventListener("click", (e) => {
            if (diffFilter.contains(e.target)) return;
            cycleDifficulty();
          });
        }
        diffFilter.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            cycleDifficulty();
          }
        });

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (
            e.target &&
            ["INPUT", "TEXTAREA", "SELECT", "BUTTON"].includes(e.target.tagName)
          )
            return;
          if (e.key === "ArrowRight") nextCard();
          else if (e.key === "ArrowLeft") prevCard();
          else if (e.key === " ") {
            e.preventDefault();
            if (!state.isTransitioning) {
              setFlipped(!state.flipped);
            }
          } else if (
            e.key.toLowerCase() === "r" &&
            !e.ctrlKey &&
            !e.metaKey &&
            !state.showFavouritesOnly
          ) {
            toggleShuffle();
          } else if (e.key.toLowerCase() === "f" && !e.ctrlKey && !e.metaKey) {
            toggleFavouritesOnly();
          } else if (e.key.toLowerCase() === "b" && !e.ctrlKey && !e.metaKey) {
            // Keyboard shortcut for bookmarking
            const currentCard = getCurrentCard();
            if (currentCard) {
              toggleFavourite(currentCard);
              updateBookmarkButton();
            }
          }
        });
      }

      (async function init() {
        bindUI();
        updateShuffleUI();
        updateFavouritesUI();
        updateTimerUI();
        updateDifficultyUI();

        showSkeleton();
        const chapters = await discoverChapters();

        if (!chapters.length) {
          hideSkeleton();
          qs("#counter").textContent =
            "Aucun chapitre trouvé (dossier 'flashcards/chN_cartes').";
          return;
        }

        const initial = buildChapterSelect(chapters);
        await loadChapter(initial);
      })();
    </script>
  </body>
</html>
